{"version":3,"file":"kriging_contour.js","sources":["../node_modules/d3-array/src/ascending.js","../node_modules/d3-array/src/bisector.js","../node_modules/d3-array/src/bisect.js","../node_modules/d3-array/src/ticks.js","../node_modules/d3-array/src/threshold/sturges.js","../node_modules/d3-contour/src/array.js","../node_modules/d3-contour/src/ascending.js","../node_modules/d3-contour/src/constant.js","../node_modules/d3-contour/src/contains.js","../node_modules/d3-contour/src/noop.js","../node_modules/d3-contour/src/contours.js","../node_modules/d3-array/src/extent.js","../node_modules/d3-array/src/range.js","../node_modules/d3-contour/src/area.js","../src/kriging.js","../node_modules/@turf/helpers/dist/es/index.js","../node_modules/@turf/invariant/dist/es/index.js","../node_modules/robust-predicates/esm/util.js","../node_modules/robust-predicates/esm/orient2d.js","../node_modules/polygon-clipping/dist/polygon-clipping.esm.js","../node_modules/@turf/intersect/dist/es/index.js","../src/index.js"],"sourcesContent":["export default function(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n","import ascending from \"./ascending\";\n\nexport default function(compare) {\n  if (compare.length === 1) compare = ascendingComparator(compare);\n  return {\n    left: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      }\n      return lo;\n    },\n    right: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) > 0) hi = mid;\n        else lo = mid + 1;\n      }\n      return lo;\n    }\n  };\n}\n\nfunction ascendingComparator(f) {\n  return function(d, x) {\n    return ascending(f(d), x);\n  };\n}\n","import ascending from \"./ascending\";\nimport bisector from \"./bisector\";\n\nvar ascendingBisect = bisector(ascending);\nexport var bisectRight = ascendingBisect.right;\nexport var bisectLeft = ascendingBisect.left;\nexport default bisectRight;\n","var e10 = Math.sqrt(50),\n    e5 = Math.sqrt(10),\n    e2 = Math.sqrt(2);\n\nexport default function(start, stop, count) {\n  var reverse,\n      i = -1,\n      n,\n      ticks,\n      step;\n\n  stop = +stop, start = +start, count = +count;\n  if (start === stop && count > 0) return [start];\n  if (reverse = stop < start) n = start, start = stop, stop = n;\n  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];\n\n  if (step > 0) {\n    start = Math.ceil(start / step);\n    stop = Math.floor(stop / step);\n    ticks = new Array(n = Math.ceil(stop - start + 1));\n    while (++i < n) ticks[i] = (start + i) * step;\n  } else {\n    start = Math.floor(start * step);\n    stop = Math.ceil(stop * step);\n    ticks = new Array(n = Math.ceil(start - stop + 1));\n    while (++i < n) ticks[i] = (start - i) / step;\n  }\n\n  if (reverse) ticks.reverse();\n\n  return ticks;\n}\n\nexport function tickIncrement(start, stop, count) {\n  var step = (stop - start) / Math.max(0, count),\n      power = Math.floor(Math.log(step) / Math.LN10),\n      error = step / Math.pow(10, power);\n  return power >= 0\n      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)\n      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n}\n\nexport function tickStep(start, stop, count) {\n  var step0 = Math.abs(stop - start) / Math.max(0, count),\n      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),\n      error = step0 / step1;\n  if (error >= e10) step1 *= 10;\n  else if (error >= e5) step1 *= 5;\n  else if (error >= e2) step1 *= 2;\n  return stop < start ? -step1 : step1;\n}\n","export default function(values) {\n  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;\n}\n","var array = Array.prototype;\n\nexport var slice = array.slice;\n","export default function(a, b) {\n  return a - b;\n}\n","export default function(x) {\n  return function() {\n    return x;\n  };\n}\n","export default function(ring, hole) {\n  var i = -1, n = hole.length, c;\n  while (++i < n) if (c = ringContains(ring, hole[i])) return c;\n  return 0;\n}\n\nfunction ringContains(ring, point) {\n  var x = point[0], y = point[1], contains = -1;\n  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {\n    var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];\n    if (segmentContains(pi, pj, point)) return 0;\n    if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;\n  }\n  return contains;\n}\n\nfunction segmentContains(a, b, c) {\n  var i; return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);\n}\n\nfunction collinear(a, b, c) {\n  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);\n}\n\nfunction within(p, q, r) {\n  return p <= q && q <= r || r <= q && q <= p;\n}\n","export default function() {}\n","import {extent, thresholdSturges, tickStep, range} from \"d3-array\";\nimport {slice} from \"./array\";\nimport ascending from \"./ascending\";\nimport area from \"./area\";\nimport constant from \"./constant\";\nimport contains from \"./contains\";\nimport noop from \"./noop\";\n\nvar cases = [\n  [],\n  [[[1.0, 1.5], [0.5, 1.0]]],\n  [[[1.5, 1.0], [1.0, 1.5]]],\n  [[[1.5, 1.0], [0.5, 1.0]]],\n  [[[1.0, 0.5], [1.5, 1.0]]],\n  [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],\n  [[[1.0, 0.5], [1.0, 1.5]]],\n  [[[1.0, 0.5], [0.5, 1.0]]],\n  [[[0.5, 1.0], [1.0, 0.5]]],\n  [[[1.0, 1.5], [1.0, 0.5]]],\n  [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],\n  [[[1.5, 1.0], [1.0, 0.5]]],\n  [[[0.5, 1.0], [1.5, 1.0]]],\n  [[[1.0, 1.5], [1.5, 1.0]]],\n  [[[0.5, 1.0], [1.0, 1.5]]],\n  []\n];\n\nexport default function() {\n  var dx = 1,\n      dy = 1,\n      threshold = thresholdSturges,\n      smooth = smoothLinear;\n\n  function contours(values) {\n    var tz = threshold(values);\n\n    // Convert number of thresholds into uniform thresholds.\n    if (!Array.isArray(tz)) {\n      var domain = extent(values), start = domain[0], stop = domain[1];\n      tz = tickStep(start, stop, tz);\n      tz = range(Math.floor(start / tz) * tz, Math.floor(stop / tz) * tz, tz);\n    } else {\n      tz = tz.slice().sort(ascending);\n    }\n\n    return tz.map(function(value) {\n      return contour(values, value);\n    });\n  }\n\n  // Accumulate, smooth contour rings, assign holes to exterior rings.\n  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js\n  function contour(values, value) {\n    var polygons = [],\n        holes = [];\n\n    isorings(values, value, function(ring) {\n      smooth(ring, values, value);\n      if (area(ring) > 0) polygons.push([ring]);\n      else holes.push(ring);\n    });\n\n    holes.forEach(function(hole) {\n      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {\n        if (contains((polygon = polygons[i])[0], hole) !== -1) {\n          polygon.push(hole);\n          return;\n        }\n      }\n    });\n\n    return {\n      type: \"MultiPolygon\",\n      value: value,\n      coordinates: polygons\n    };\n  }\n\n  // Marching squares with isolines stitched into rings.\n  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js\n  function isorings(values, value, callback) {\n    var fragmentByStart = new Array,\n        fragmentByEnd = new Array,\n        x, y, t0, t1, t2, t3;\n\n    // Special case for the first row (y = -1, t2 = t3 = 0).\n    x = y = -1;\n    t1 = values[0] >= value;\n    cases[t1 << 1].forEach(stitch);\n    while (++x < dx - 1) {\n      t0 = t1, t1 = values[x + 1] >= value;\n      cases[t0 | t1 << 1].forEach(stitch);\n    }\n    cases[t1 << 0].forEach(stitch);\n\n    // General case for the intermediate rows.\n    while (++y < dy - 1) {\n      x = -1;\n      t1 = values[y * dx + dx] >= value;\n      t2 = values[y * dx] >= value;\n      cases[t1 << 1 | t2 << 2].forEach(stitch);\n      while (++x < dx - 1) {\n        t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;\n        t3 = t2, t2 = values[y * dx + x + 1] >= value;\n        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);\n      }\n      cases[t1 | t2 << 3].forEach(stitch);\n    }\n\n    // Special case for the last row (y = dy - 1, t0 = t1 = 0).\n    x = -1;\n    t2 = values[y * dx] >= value;\n    cases[t2 << 2].forEach(stitch);\n    while (++x < dx - 1) {\n      t3 = t2, t2 = values[y * dx + x + 1] >= value;\n      cases[t2 << 2 | t3 << 3].forEach(stitch);\n    }\n    cases[t2 << 3].forEach(stitch);\n\n    function stitch(line) {\n      var start = [line[0][0] + x, line[0][1] + y],\n          end = [line[1][0] + x, line[1][1] + y],\n          startIndex = index(start),\n          endIndex = index(end),\n          f, g;\n      if (f = fragmentByEnd[startIndex]) {\n        if (g = fragmentByStart[endIndex]) {\n          delete fragmentByEnd[f.end];\n          delete fragmentByStart[g.start];\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};\n          }\n        } else {\n          delete fragmentByEnd[f.end];\n          f.ring.push(end);\n          fragmentByEnd[f.end = endIndex] = f;\n        }\n      } else if (f = fragmentByStart[endIndex]) {\n        if (g = fragmentByEnd[startIndex]) {\n          delete fragmentByStart[f.start];\n          delete fragmentByEnd[g.end];\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};\n          }\n        } else {\n          delete fragmentByStart[f.start];\n          f.ring.unshift(start);\n          fragmentByStart[f.start = startIndex] = f;\n        }\n      } else {\n        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};\n      }\n    }\n  }\n\n  function index(point) {\n    return point[0] * 2 + point[1] * (dx + 1) * 4;\n  }\n\n  function smoothLinear(ring, values, value) {\n    ring.forEach(function(point) {\n      var x = point[0],\n          y = point[1],\n          xt = x | 0,\n          yt = y | 0,\n          v0,\n          v1 = values[yt * dx + xt];\n      if (x > 0 && x < dx && xt === x) {\n        v0 = values[yt * dx + xt - 1];\n        point[0] = x + (value - v0) / (v1 - v0) - 0.5;\n      }\n      if (y > 0 && y < dy && yt === y) {\n        v0 = values[(yt - 1) * dx + xt];\n        point[1] = y + (value - v0) / (v1 - v0) - 0.5;\n      }\n    });\n  }\n\n  contours.contour = contour;\n\n  contours.size = function(_) {\n    if (!arguments.length) return [dx, dy];\n    var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);\n    if (!(_0 > 0) || !(_1 > 0)) throw new Error(\"invalid size\");\n    return dx = _0, dy = _1, contours;\n  };\n\n  contours.thresholds = function(_) {\n    return arguments.length ? (threshold = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), contours) : threshold;\n  };\n\n  contours.smooth = function(_) {\n    return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;\n  };\n\n  return contours;\n}\n","export default function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      min,\n      max;\n\n  if (valueof == null) {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = values[i]) != null && value >= value) {\n        min = max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = values[i]) != null) {\n            if (min > value) min = value;\n            if (max < value) max = value;\n          }\n        }\n      }\n    }\n  }\n\n  else {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = valueof(values[i], i, values)) != null && value >= value) {\n        min = max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = valueof(values[i], i, values)) != null) {\n            if (min > value) min = value;\n            if (max < value) max = value;\n          }\n        }\n      }\n    }\n  }\n\n  return [min, max];\n}\n","export default function(start, stop, step) {\n  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n\n  var i = -1,\n      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,\n      range = new Array(n);\n\n  while (++i < n) {\n    range[i] = start + i * step;\n  }\n\n  return range;\n}\n","export default function(ring) {\n  var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];\n  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];\n  return area;\n}\n","import {contours as d3_contours} from 'd3-contour';\n\n//数组最大值\nArray.prototype.max = function () {\n\treturn Math.max.apply(null, this);\n};\n//数组最小值\nArray.prototype.min = function () {\n\treturn Math.min.apply(null, this);\n};\n//数组平均值\nArray.prototype.mean = function () {\n\tvar i,\n\tsum;\n\tfor (i = 0, sum = 0; i < this.length; i++)\n\t\tsum += this[i];\n\treturn sum / this.length;\n};\n\n//将数组第一项取出为v，生成长度为n的数组，每个数组item为v\nArray.prototype.rep = function (n) {\n\tvar arrayn = new Array(n);\n\tvar v = this[0];\n\tfor (var i = 0; i < n; i++) {\n\t\tarrayn[i] = v;\n\t}\n\treturn arrayn;\n};\n\nArray.prototype.pip = function (x, y) {\n\tvar i,\n\tj,\n\tc = false;\n\tfor (i = 0, j = this.length - 1; i < this.length; j = i++) {\n\t\tif (((this[i][1] > y) != (this[j][1] > y)) &&\n\t\t\t(x < (this[j][0] - this[i][0]) * (y - this[i][1]) / (this[j][1] - this[i][1]) + this[i][0])) {\n\t\t\tc = !c;\n\t\t}\n\t}\n\treturn c;\n}\n\n// Matrix algebra\nfunction kriging_matrix_diag(c, n) {\n\tvar i,\n\tZ = [0].rep(n * n);\n\tfor (i = 0; i < n; i++)\n\t\tZ[i * n + i] = c;\n\treturn Z;\n};\nfunction kriging_matrix_transpose(X, n, m) {\n\tvar i,\n\tj,\n\tZ = Array(m * n);\n\tfor (i = 0; i < n; i++)\n\t\tfor (j = 0; j < m; j++)\n\t\t\tZ[j * n + i] = X[i * m + j];\n\treturn Z;\n};\nfunction kriging_matrix_scale(X, c, n, m) {\n\tvar i,\n\tj;\n\tfor (i = 0; i < n; i++)\n\t\tfor (j = 0; j < m; j++)\n\t\t\tX[i * m + j] *= c;\n};\nfunction kriging_matrix_add(X, Y, n, m) {\n\tvar i,\n\tj,\n\tZ = Array(n * m);\n\tfor (i = 0; i < n; i++)\n\t\tfor (j = 0; j < m; j++)\n\t\t\tZ[i * m + j] = X[i * m + j] + Y[i * m + j];\n\treturn Z;\n};\n// Naive matrix multiplication\nfunction kriging_matrix_multiply(X, Y, n, m, p) {\n\tvar i,\n\tj,\n\tk,\n\tZ = Array(n * p);\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < p; j++) {\n\t\t\tZ[i * p + j] = 0;\n\t\t\tfor (k = 0; k < m; k++)\n\t\t\t\tZ[i * p + j] += X[i * m + k] * Y[k * p + j];\n\t\t}\n\t}\n\treturn Z;\n};\n// Cholesky decomposition\nfunction kriging_matrix_chol(X, n) {\n\tvar i,\n\tj,\n\tk,\n\tsum,\n\tp = Array(n);\n\tfor (i = 0; i < n; i++)\n\t\tp[i] = X[i * n + i];\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < i; j++)\n\t\t\tp[i] -= X[i * n + j] * X[i * n + j];\n\t\tif (p[i] <= 0)\n\t\t\treturn false;\n\t\tp[i] = Math.sqrt(p[i]);\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tfor (k = 0; k < i; k++)\n\t\t\t\tX[j * n + i] -= X[j * n + k] * X[i * n + k];\n\t\t\tX[j * n + i] /= p[i];\n\t\t}\n\t}\n\tfor (i = 0; i < n; i++)\n\t\tX[i * n + i] = p[i];\n\treturn true;\n};\n// Inversion of cholesky decomposition\nfunction kriging_matrix_chol2inv(X, n) {\n\tvar i,\n\tj,\n\tk,\n\tsum;\n\tfor (i = 0; i < n; i++) {\n\t\tX[i * n + i] = 1 / X[i * n + i];\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tsum = 0;\n\t\t\tfor (k = i; k < j; k++)\n\t\t\t\tsum -= X[j * n + k] * X[k * n + i];\n\t\t\tX[j * n + i] = sum / X[j * n + j];\n\t\t}\n\t}\n\tfor (i = 0; i < n; i++)\n\t\tfor (j = i + 1; j < n; j++)\n\t\t\tX[i * n + j] = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tX[i * n + i] *= X[i * n + i];\n\t\tfor (k = i + 1; k < n; k++)\n\t\t\tX[i * n + i] += X[k * n + i] * X[k * n + i];\n\t\tfor (j = i + 1; j < n; j++)\n\t\t\tfor (k = j; k < n; k++)\n\t\t\t\tX[i * n + j] += X[k * n + i] * X[k * n + j];\n\t}\n\tfor (i = 0; i < n; i++)\n\t\tfor (j = 0; j < i; j++)\n\t\t\tX[i * n + j] = X[j * n + i];\n\n};\n// Inversion via gauss-jordan elimination\nfunction kriging_matrix_solve(X, n) {\n\tvar m = n;\n\tvar b = Array(n * n);\n\tvar indxc = Array(n);\n\tvar indxr = Array(n);\n\tvar ipiv = Array(n);\n\tvar i,\n\ticol,\n\tirow,\n\tj,\n\tk,\n\tl,\n\tll;\n\tvar big,\n\tdum,\n\tpivinv,\n\ttemp;\n\n\tfor (i = 0; i < n; i++)\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (i == j)\n\t\t\t\tb[i * n + j] = 1;\n\t\t\telse\n\t\t\t\tb[i * n + j] = 0;\n\t\t}\n\tfor (j = 0; j < n; j++)\n\t\tipiv[j] = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tbig = 0;\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (ipiv[j] != 1) {\n\t\t\t\tfor (k = 0; k < n; k++) {\n\t\t\t\t\tif (ipiv[k] == 0) {\n\t\t\t\t\t\tif (Math.abs(X[j * n + k]) >= big) {\n\t\t\t\t\t\t\tbig = Math.abs(X[j * n + k]);\n\t\t\t\t\t\t\tirow = j;\n\t\t\t\t\t\t\ticol = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++(ipiv[icol]);\n\n\t\tif (irow != icol) {\n\t\t\tfor (l = 0; l < n; l++) {\n\t\t\t\ttemp = X[irow * n + l];\n\t\t\t\tX[irow * n + l] = X[icol * n + l];\n\t\t\t\tX[icol * n + l] = temp;\n\t\t\t}\n\t\t\tfor (l = 0; l < m; l++) {\n\t\t\t\ttemp = b[irow * n + l];\n\t\t\t\tb[irow * n + l] = b[icol * n + l];\n\t\t\t\tb[icol * n + l] = temp;\n\t\t\t}\n\t\t}\n\t\tindxr[i] = irow;\n\t\tindxc[i] = icol;\n\n\t\tif (X[icol * n + icol] == 0)\n\t\t\treturn false; // Singular\n\n\t\tpivinv = 1 / X[icol * n + icol];\n\t\tX[icol * n + icol] = 1;\n\t\tfor (l = 0; l < n; l++)\n\t\t\tX[icol * n + l] *= pivinv;\n\t\tfor (l = 0; l < m; l++)\n\t\t\tb[icol * n + l] *= pivinv;\n\n\t\tfor (ll = 0; ll < n; ll++) {\n\t\t\tif (ll != icol) {\n\t\t\t\tdum = X[ll * n + icol];\n\t\t\t\tX[ll * n + icol] = 0;\n\t\t\t\tfor (l = 0; l < n; l++)\n\t\t\t\t\tX[ll * n + l] -= X[icol * n + l] * dum;\n\t\t\t\tfor (l = 0; l < m; l++)\n\t\t\t\t\tb[ll * n + l] -= b[icol * n + l] * dum;\n\t\t\t}\n\t\t}\n\t}\n\tfor (l = (n - 1); l >= 0; l--)\n\t\tif (indxr[l] != indxc[l]) {\n\t\t\tfor (k = 0; k < n; k++) {\n\t\t\t\ttemp = X[k * n + indxr[l]];\n\t\t\t\tX[k * n + indxr[l]] = X[k * n + indxc[l]];\n\t\t\t\tX[k * n + indxc[l]] = temp;\n\t\t\t}\n\t\t}\n\n\treturn true;\n}\n\n// Variogram models\nfunction kriging_variogram_gaussian(h, nugget, range, sill, A) {\n\treturn nugget + ((sill - nugget) / range) *\n\t(1.0 - Math.exp( - (1.0 / A) * Math.pow(h / range, 2)));\n};\nfunction kriging_variogram_exponential(h, nugget, range, sill, A) {\n\treturn nugget + ((sill - nugget) / range) *\n\t(1.0 - Math.exp( - (1.0 / A) * (h / range)));\n};\nfunction kriging_variogram_spherical(h, nugget, range, sill, A) {\n\tif (h > range)\n\t\treturn nugget + (sill - nugget) / range;\n\treturn nugget + ((sill - nugget) / range) *\n\t(1.5 * (h / range) - 0.5 * Math.pow(h / range, 3));\n};\n\nvar kriging = {\n\n};\n\n\n\n\n// Train using gaussian processes with bayesian priors\nkriging.train = function (t, x, y, model, sigma2, alpha) {\n\tvar variogram = {\n\t\tt : t,\n\t\tx : x,\n\t\ty : y,\n\t\tnugget : 0.0,\n\t\trange : 0.0,\n\t\tsill : 0.0,\n\t\tA : 1 / 3,\n\t\tn : 0\n\t};\n\tswitch (model) {\n\tcase \"gaussian\":\n\t\tvariogram.model = kriging_variogram_gaussian;\n\t\tbreak;\n\tcase \"exponential\":\n\t\tvariogram.model = kriging_variogram_exponential;\n\t\tbreak;\n\tcase \"spherical\":\n\t\tvariogram.model = kriging_variogram_spherical;\n\t\tbreak;\n\t};\n\n\t// Lag distance/semivariance\n\tvar i,\n\tj,\n\tk,\n\tl,\n\tn = t.length;\n\tvar distance = Array((n * n - n) / 2);\n\tfor (i = 0, k = 0; i < n; i++)\n\t\tfor (j = 0; j < i; j++, k++) {\n\t\t\tdistance[k] = Array(2);\n\t\t\tdistance[k][0] = Math.pow(\n\t\t\t\t\tMath.pow(x[i] - x[j], 2) +\n\t\t\t\t\tMath.pow(y[i] - y[j], 2), 0.5);\n\t\t\tdistance[k][1] = Math.abs(t[i] - t[j]);\n\t\t}\n\tdistance.sort(function (a, b) {\n\t\treturn a[0] - b[0];\n\t});\n\tvariogram.range = distance[(n * n - n) / 2 - 1][0];\n\n\t// Bin lag distance\n\tvar lags = ((n * n - n) / 2) > 30 ? 30 : (n * n - n) / 2;\n\tvar tolerance = variogram.range / lags;\n\tvar lag = [0].rep(lags);\n\tvar semi = [0].rep(lags);\n\tif (lags < 30) {\n\t\tfor (l = 0; l < lags; l++) {\n\t\t\tlag[l] = distance[l][0];\n\t\t\tsemi[l] = distance[l][1];\n\t\t}\n\t} else {\n\t\tfor (i = 0, j = 0, k = 0, l = 0; i < lags && j < ((n * n - n) / 2); i++, k = 0) {\n\t\t\twhile (distance[j][0] <= ((i + 1) * tolerance)) {\n\t\t\t\tlag[l] += distance[j][0];\n\t\t\t\tsemi[l] += distance[j][1];\n\t\t\t\tj++;\n\t\t\t\tk++;\n\t\t\t\tif (j >= ((n * n - n) / 2))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (k > 0) {\n\t\t\t\tlag[l] /= k;\n\t\t\t\tsemi[l] /= k;\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t\tif (l < 2)\n\t\t\treturn variogram; // Error: Not enough points\n\t}\n\n\t// Feature transformation\n\tn = l;\n\tvariogram.range = lag[n - 1] - lag[0];\n\tvar X = [1].rep(2 * n);\n\tvar Y = Array(n);\n\tvar A = variogram.A;\n\tfor (i = 0; i < n; i++) {\n\t\tswitch (model) {\n\t\tcase \"gaussian\":\n\t\t\tX[i * 2 + 1] = 1.0 - Math.exp( - (1.0 / A) * Math.pow(lag[i] / variogram.range, 2));\n\t\t\tbreak;\n\t\tcase \"exponential\":\n\t\t\tX[i * 2 + 1] = 1.0 - Math.exp( - (1.0 / A) * lag[i] / variogram.range);\n\t\t\tbreak;\n\t\tcase \"spherical\":\n\t\t\tX[i * 2 + 1] = 1.5 * (lag[i] / variogram.range) -\n\t\t\t\t0.5 * Math.pow(lag[i] / variogram.range, 3);\n\t\t\tbreak;\n\t\t};\n\t\tY[i] = semi[i];\n\t}\n\n\t// Least squares\n\tvar Xt = kriging_matrix_transpose(X, n, 2);\n\tvar Z = kriging_matrix_multiply(Xt, X, 2, n, 2);\n\tZ = kriging_matrix_add(Z, kriging_matrix_diag(1 / alpha, 2), 2, 2);\n\tvar cloneZ = Z.slice(0);\n\tif (kriging_matrix_chol(Z, 2))\n\t\tkriging_matrix_chol2inv(Z, 2);\n\telse {\n\t\tkriging_matrix_solve(cloneZ, 2);\n\t\tZ = cloneZ;\n\t}\n\tvar W = kriging_matrix_multiply(kriging_matrix_multiply(Z, Xt, 2, 2, n), Y, 2, n, 1);\n\n\t// Variogram parameters\n\tvariogram.nugget = W[0];\n\tvariogram.sill = W[1] * variogram.range + variogram.nugget;\n\tvariogram.n = x.length;\n\n\t// Gram matrix with prior\n\tn = x.length;\n\tvar K = Array(n * n);\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tK[i * n + j] = variogram.model(Math.pow(Math.pow(x[i] - x[j], 2) +\n\t\t\t\t\t\tMath.pow(y[i] - y[j], 2), 0.5),\n\t\t\t\t\tvariogram.nugget,\n\t\t\t\t\tvariogram.range,\n\t\t\t\t\tvariogram.sill,\n\t\t\t\t\tvariogram.A);\n\t\t\tK[j * n + i] = K[i * n + j];\n\t\t}\n\t\tK[i * n + i] = variogram.model(0, variogram.nugget,\n\t\t\t\tvariogram.range,\n\t\t\t\tvariogram.sill,\n\t\t\t\tvariogram.A);\n\t}\n\n\t// Inverse penalized Gram matrix projected to target vector\n\tvar C = kriging_matrix_add(K, kriging_matrix_diag(sigma2, n), n, n);\n\tvar cloneC = C.slice(0);\n\tif (kriging_matrix_chol(C, n))\n\t\tkriging_matrix_chol2inv(C, n);\n\telse {\n\t\tkriging_matrix_solve(cloneC, n);\n\t\tC = cloneC;\n\t}\n\n\t// Copy unprojected inverted matrix as K\n\tvar K = C.slice(0);\n\tvar M = kriging_matrix_multiply(C, t, n, n, 1);\n\tvariogram.K = K;\n\tvariogram.M = M;\n\n\treturn variogram;\n};\n\n// Model prediction\nkriging.predict = function (x, y, variogram) {\n\tvar i,\n\tk = Array(variogram.n);\n\tfor (i = 0; i < variogram.n; i++)\n\t\tk[i] = variogram.model(Math.pow(Math.pow(x - variogram.x[i], 2) +\n\t\t\t\t\tMath.pow(y - variogram.y[i], 2), 0.5),\n\t\t\t\tvariogram.nugget, variogram.range,\n\t\t\t\tvariogram.sill, variogram.A);\n\treturn kriging_matrix_multiply(k, variogram.M, 1, variogram.n, 1)[0];\n};\nkriging.variance = function (x, y, variogram) {\n\tvar i,\n\tk = Array(variogram.n);\n\tfor (i = 0; i < variogram.n; i++)\n\t\tk[i] = variogram.model(Math.pow(Math.pow(x - variogram.x[i], 2) +\n\t\t\t\t\tMath.pow(y - variogram.y[i], 2), 0.5),\n\t\t\t\tvariogram.nugget, variogram.range,\n\t\t\t\tvariogram.sill, variogram.A);\n\treturn variogram.model(0, variogram.nugget, variogram.range,\n\t\tvariogram.sill, variogram.A) +\n\tkriging_matrix_multiply(kriging_matrix_multiply(k, variogram.K,\n\t\t\t1, variogram.n, variogram.n),\n\t\tk, 1, variogram.n, 1)[0];\n};\n\n// 生成克里金grid\nkriging.getGridInfo = function (bbox,variogram,width) {\n\tvar grid = [];\n\t//x方向\n\tvar xlim=[bbox[0],bbox[2]];\n\tvar ylim=[bbox[1],bbox[3]];\n\tvar zlim=[variogram.t.min(), variogram.t.max()];\n\t\n\t//xy方向地理跨度\n\tvar geoX_width=xlim[1]-xlim[0];\n\tvar geoY_width=ylim[1]-ylim[0];\n\n\t//如果x_width设置，初始基于200计算。\n\tlet x_width,y_width;\n\tif(!width)\n\t\tx_width=200;\n\telse\n\t\tx_width=Math.ceil(width);\n\t//让图像的xy比例与地理的xy比例保持一致\n\ty_width=Math.ceil(x_width/(geoX_width/geoY_width));\n\n\t//地理跨度/图像跨度=当前地图图上分辨率\n\tvar x_resolution=geoX_width*1.0/x_width;\n\tvar y_resolution=geoY_width*1.0/y_width;\n\t\n\tvar xtarget,ytarget;\n\n\tfor (let j = 0; j < y_width; j++) {\n\t\tfor (let k =0; k <x_width; k++) {\n\t\t\txtarget = bbox[0] + k * x_resolution;\n\t\t\tytarget = bbox[1] + j * y_resolution;\n\t\t\tgrid.push(kriging.predict(xtarget, ytarget, variogram));\n\t\t}\n\t}\n\treturn {\n\t\tgrid : grid,\n\t\tn : x_width,\n\t\tm : y_width,\n\t\txlim : xlim,\n\t\tylim : ylim,\n\t\tzlim : zlim,\n\t\tx_resolution:x_resolution,\n\t\ty_resolution:y_resolution\n\n\t};\n};\n\n\n//克里金生成矢量等值面\nkriging.getVectorContour = function (gridInfo, breaks) {\n\t//像素坐标系的等值面\n\tvar _contours = d3_contours()\n\t\t.size([gridInfo.n, gridInfo.m])\n\t\t.thresholds(breaks)\n\t\t(gridInfo.grid);\n\t//像素坐标系换算地理坐标系\n\tlet dataset = {\n\t\t\"type\" : \"FeatureCollection\",\n\t\t\"features\" : []\n\t};\n\tfor(let i=0;i<_contours.length;i++){\n\t\tconst contour = _contours[i];\n\t\tif(contour.type==='MultiPolygon'){\n\t\t\tcontour.coordinates.forEach(polygon => {\n\t\t\t\tlet geom = {\n\t\t\t\t\t\"type\" : \"Polygon\",\n\t\t\t\t\t\"coordinates\" : []\n\t\t\t\t};\n\t\t\t\t//坐标转换，图形为空去除\n\t\t\t\tgeom.coordinates=polygon_pixel2geos(polygon,gridInfo);\n\t\t\t\tif(geom.coordinates.length>0){\n\t\t\t\t\tdataset.features.push({\n\t\t\t\t\t\t\"type\" : \"Feature\",\n\t\t\t\t\t\t\"properties\" : {\n\t\t\t\t\t\t\t\"value\" : contour.value\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"geometry\" :geom\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\telse if(contour.type==='Polygon'){\n\t\t\tlet geom = {\n\t\t\t\t\"type\" : \"Polygon\",\n\t\t\t\t\"coordinates\" : []\n\t\t\t};\n\t\t\t//坐标转换，图形为空去除\n\t\t\tgeom.coordinates=polygon_pixel2geos(contour.coordinates,gridInfo);\n\t\t\tif(geom.coordinates.length>0){\n\t\t\t\tdataset.features.push({\n\t\t\t\t\t\"type\" : \"Feature\",\n\t\t\t\t\t\"properties\" : {\n\t\t\t\t\t\t\"value\" : contour.value\n\t\t\t\t\t},\n\t\t\t\t\t\"geometry\" :geom\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\treturn dataset;\n};\n//像素坐标转地理坐标\nfunction polygon_pixel2geos(polygon,gridInfo){\n\t//polygon分内环和外环\n\tconst _polygon = polygon.map((ring) => {\n\t\tconst _ring = ring.map(function (coor) {\n\t\t\t//像素坐标转地理坐标 ，像素坐标y方向从上到下递增，纬度是y从上到下递减\n\t\t\tconst lon = gridInfo.xlim[0] + coor[0]*gridInfo.x_resolution;\n\t\t\tlet lat;\n\t\t\t//格网自上向下走\n\t\t\tif(gridInfo.y_resolution<0)\n\t\t\t\tlat=gridInfo.ylim[1] + coor[1]*gridInfo.y_resolution;\n\t\t\t//格网自下向上走\n\t\t\telse\n\t\t\t\tlat=gridInfo.ylim[0] + coor[1]*gridInfo.y_resolution;\n\t\n\t\t\treturn [lon,lat];\n\t\t});\n\t\treturn _ring;\n\t});\t\n\treturn _polygon;\n}\n//克里金生成canvas图像\n kriging.drawCanvasContour = function(gridInfo,canvas,xlim,ylim,colors) {\n\t//清空画布\n\tvar ctx = canvas.getContext(\"2d\");\n\tctx.clearRect(0, 0, canvas.width, canvas.height);\n\t//开始边界\n\tvar range = [xlim[1]-xlim[0], ylim[1]-ylim[0], gridInfo.zlim[1]-gridInfo.zlim[0]];\n\tvar n = gridInfo.n;\n\tvar m = gridInfo.m;\n\t//根据分辨率，计算每个色块的宽高\n\tvar wx = Math.ceil(gridInfo.x_resolution*canvas.width/(xlim[1]-xlim[0]));\n\tvar wy = Math.ceil(gridInfo.y_resolution*canvas.height/(ylim[1]-ylim[0]));\n\n\tfor(let i=0;i<m;i++)\n\t    for(let j=0;j<n;j++) {\n\t\t\tlet _index=i*n+j;\n\t\t\tif(gridInfo.grid[_index]==undefined) \n\t\t\t\tcontinue;\n\t\t\tlet x = canvas.width*(j*gridInfo.x_resolution+gridInfo.xlim[0]-xlim[0])/range[0];\n\t\t\tlet y = canvas.height*(1-(i*gridInfo.y_resolution+gridInfo.ylim[0]-ylim[0])/range[1]);\n\t\t\tlet z = (gridInfo.grid[_index]-gridInfo.zlim[0])/range[2];\n\t\t\tif(z<0.0) \n\t\t\t\tz = 0.0;\n\t\t\telse if(z>1.0) \n\t\t\t\tz = 1.0;\n\t\t\tctx.fillStyle = colors[Math.floor((colors.length-1)*z)];\n\t\t\tctx.fillRect(Math.round(x-wx/2), Math.round(y-wy/2), wx, wy);\n\t    }\n\t};\n\nexport {kriging};\n","/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","export const epsilon = 1.1102230246251565e-16;\nexport const splitter = 134217729;\nexport const resulterrbound = (3 + 8 * epsilon) * epsilon;\n\n// fast_expansion_sum_zeroelim routine from oritinal code\nexport function sum(elen, e, flen, f, h) {\n    let Q, Qnew, hh, bvirt;\n    let enow = e[0];\n    let fnow = f[0];\n    let eindex = 0;\n    let findex = 0;\n    if ((fnow > enow) === (fnow > -enow)) {\n        Q = enow;\n        enow = e[++eindex];\n    } else {\n        Q = fnow;\n        fnow = f[++findex];\n    }\n    let hindex = 0;\n    if (eindex < elen && findex < flen) {\n        if ((fnow > enow) === (fnow > -enow)) {\n            Qnew = enow + Q;\n            hh = Q - (Qnew - enow);\n            enow = e[++eindex];\n        } else {\n            Qnew = fnow + Q;\n            hh = Q - (Qnew - fnow);\n            fnow = f[++findex];\n        }\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        while (eindex < elen && findex < flen) {\n            if ((fnow > enow) === (fnow > -enow)) {\n                Qnew = Q + enow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (enow - bvirt);\n                enow = e[++eindex];\n            } else {\n                Qnew = Q + fnow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n                fnow = f[++findex];\n            }\n            Q = Qnew;\n            if (hh !== 0) {\n                h[hindex++] = hh;\n            }\n        }\n    }\n    while (eindex < elen) {\n        Qnew = Q + enow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (enow - bvirt);\n        enow = e[++eindex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    while (findex < flen) {\n        Qnew = Q + fnow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n        fnow = f[++findex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function sum_three(alen, a, blen, b, clen, c, tmp, out) {\n    return sum(sum(alen, a, blen, b, tmp), tmp, clen, c, out);\n}\n\n// scale_expansion_zeroelim routine from oritinal code\nexport function scale(elen, e, b, h) {\n    let Q, sum, hh, product1, product0;\n    let bvirt, c, ahi, alo, bhi, blo;\n\n    c = splitter * b;\n    bhi = c - (c - b);\n    blo = b - bhi;\n    let enow = e[0];\n    Q = enow * b;\n    c = splitter * enow;\n    ahi = c - (c - enow);\n    alo = enow - ahi;\n    hh = alo * blo - (Q - ahi * bhi - alo * bhi - ahi * blo);\n    let hindex = 0;\n    if (hh !== 0) {\n        h[hindex++] = hh;\n    }\n    for (let i = 1; i < elen; i++) {\n        enow = e[i];\n        product1 = enow * b;\n        c = splitter * enow;\n        ahi = c - (c - enow);\n        alo = enow - ahi;\n        product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);\n        sum = Q + product0;\n        bvirt = sum - Q;\n        hh = Q - (sum - bvirt) + (product0 - bvirt);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        Q = product1 + sum;\n        hh = sum - (Q - product1);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function negate(elen, e) {\n    for (let i = 0; i < elen; i++) e[i] = -e[i];\n    return elen;\n}\n\nexport function estimate(elen, e) {\n    let Q = e[0];\n    for (let i = 1; i < elen; i++) Q += e[i];\n    return Q;\n}\n\nexport function vec(n) {\n    return new Float64Array(n);\n}\n","import {epsilon, splitter, resulterrbound, estimate, vec, sum} from './util.js';\n\nconst ccwerrboundA = (3 + 16 * epsilon) * epsilon;\nconst ccwerrboundB = (2 + 12 * epsilon) * epsilon;\nconst ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;\n\nconst B = vec(4);\nconst C1 = vec(8);\nconst C2 = vec(12);\nconst D = vec(16);\nconst u = vec(4);\n\nfunction orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n    let acxtail, acytail, bcxtail, bcytail;\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    const acx = ax - cx;\n    const bcx = bx - cx;\n    const acy = ay - cy;\n    const bcy = by - cy;\n\n    s1 = acx * bcy;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcx;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    B[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    B[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    B[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    B[3] = u3;\n\n    let det = estimate(4, B);\n    let errbound = ccwerrboundB * detsum;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - acx;\n    acxtail = ax - (acx + bvirt) + (bvirt - cx);\n    bvirt = bx - bcx;\n    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n    bvirt = ay - acy;\n    acytail = ay - (acy + bvirt) + (bvirt - cy);\n    bvirt = by - bcy;\n    bcytail = by - (bcy + bvirt) + (bvirt - cy);\n\n    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n        return det;\n    }\n\n    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);\n    if (det >= errbound || -det >= errbound) return det;\n\n    s1 = acxtail * bcy;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcx;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C1len = sum(4, B, 4, u, C1);\n\n    s1 = acx * bcytail;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcxtail;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C2len = sum(C1len, C1, 4, u, C2);\n\n    s1 = acxtail * bcytail;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcxtail;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const Dlen = sum(C2len, C2, 4, u, D);\n\n    return D[Dlen - 1];\n}\n\nexport function orient2d(ax, ay, bx, by, cx, cy) {\n    const detleft = (ay - cy) * (bx - cx);\n    const detright = (ax - cx) * (by - cy);\n    const det = detleft - detright;\n\n    const detsum = Math.abs(detleft + detright);\n    if (Math.abs(det) >= ccwerrboundA * detsum) return det;\n\n    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n}\n\nexport function orient2dfast(ax, ay, bx, by, cx, cy) {\n    return (ay - cy) * (bx - cx) - (ax - cx) * (by - cy);\n}\n","import SplayTree from 'splaytree';\nimport { orient2d } from 'robust-predicates';\n\n/**\n * A bounding box has the format:\n *\n *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n *\n */\n\nconst isInBbox = (bbox, point) => {\n  return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;\n};\n\n/* Returns either null, or a bbox (aka an ordered pair of points)\n * If there is only one point of overlap, a bbox with identical points\n * will be returned */\nconst getBboxOverlap = (b1, b2) => {\n  // check if the bboxes overlap at all\n  if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null;\n\n  // find the middle two X values\n  const lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;\n  const upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;\n\n  // find the middle two Y values\n  const lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;\n  const upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;\n\n  // put those middle values together to get the overlap\n  return {\n    ll: {\n      x: lowerX,\n      y: lowerY\n    },\n    ur: {\n      x: upperX,\n      y: upperY\n    }\n  };\n};\n\n/* Javascript doesn't do integer math. Everything is\n * floating point with percision Number.EPSILON.\n *\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n */\n\nlet epsilon = Number.EPSILON;\n\n// IE Polyfill\nif (epsilon === undefined) epsilon = Math.pow(2, -52);\nconst EPSILON_SQ = epsilon * epsilon;\n\n/* FLP comparator */\nconst cmp = (a, b) => {\n  // check if they're both 0\n  if (-epsilon < a && a < epsilon) {\n    if (-epsilon < b && b < epsilon) {\n      return 0;\n    }\n  }\n\n  // check if they're flp equal\n  const ab = a - b;\n  if (ab * ab < EPSILON_SQ * a * b) {\n    return 0;\n  }\n\n  // normal comparison\n  return a < b ? -1 : 1;\n};\n\n/**\n * This class rounds incoming values sufficiently so that\n * floating points problems are, for the most part, avoided.\n *\n * Incoming points are have their x & y values tested against\n * all previously seen x & y values. If either is 'too close'\n * to a previously seen value, it's value is 'snapped' to the\n * previously seen value.\n *\n * All points should be rounded by this class before being\n * stored in any data structures in the rest of this algorithm.\n */\n\nclass PtRounder {\n  constructor() {\n    this.reset();\n  }\n  reset() {\n    this.xRounder = new CoordRounder();\n    this.yRounder = new CoordRounder();\n  }\n  round(x, y) {\n    return {\n      x: this.xRounder.round(x),\n      y: this.yRounder.round(y)\n    };\n  }\n}\nclass CoordRounder {\n  constructor() {\n    this.tree = new SplayTree();\n    // preseed with 0 so we don't end up with values < Number.EPSILON\n    this.round(0);\n  }\n\n  // Note: this can rounds input values backwards or forwards.\n  //       You might ask, why not restrict this to just rounding\n  //       forwards? Wouldn't that allow left endpoints to always\n  //       remain left endpoints during splitting (never change to\n  //       right). No - it wouldn't, because we snap intersections\n  //       to endpoints (to establish independence from the segment\n  //       angle for t-intersections).\n  round(coord) {\n    const node = this.tree.add(coord);\n    const prevNode = this.tree.prev(node);\n    if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {\n      this.tree.remove(coord);\n      return prevNode.key;\n    }\n    const nextNode = this.tree.next(node);\n    if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {\n      this.tree.remove(coord);\n      return nextNode.key;\n    }\n    return coord;\n  }\n}\n\n// singleton available by import\nconst rounder = new PtRounder();\n\n/* Cross Product of two vectors with first point at origin */\nconst crossProduct = (a, b) => a.x * b.y - a.y * b.x;\n\n/* Dot Product of two vectors with first point at origin */\nconst dotProduct = (a, b) => a.x * b.x + a.y * b.y;\n\n/* Comparator for two vectors with same starting point */\nconst compareVectorAngles = (basePt, endPt1, endPt2) => {\n  const res = orient2d(basePt.x, basePt.y, endPt1.x, endPt1.y, endPt2.x, endPt2.y);\n  if (res > 0) return -1;\n  if (res < 0) return 1;\n  return 0;\n};\nconst length = v => Math.sqrt(dotProduct(v, v));\n\n/* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\nconst sineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = {\n    x: pBase.x - pShared.x,\n    y: pBase.y - pShared.y\n  };\n  const vAngle = {\n    x: pAngle.x - pShared.x,\n    y: pAngle.y - pShared.y\n  };\n  return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n\n/* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\nconst cosineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = {\n    x: pBase.x - pShared.x,\n    y: pBase.y - pShared.y\n  };\n  const vAngle = {\n    x: pAngle.x - pShared.x,\n    y: pAngle.y - pShared.y\n  };\n  return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n\n/* Get the x coordinate where the given line (defined by a point and vector)\n * crosses the horizontal line with the given y coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nconst horizontalIntersection = (pt, v, y) => {\n  if (v.y === 0) return null;\n  return {\n    x: pt.x + v.x / v.y * (y - pt.y),\n    y: y\n  };\n};\n\n/* Get the y coordinate where the given line (defined by a point and vector)\n * crosses the vertical line with the given x coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nconst verticalIntersection = (pt, v, x) => {\n  if (v.x === 0) return null;\n  return {\n    x: x,\n    y: pt.y + v.y / v.x * (x - pt.x)\n  };\n};\n\n/* Get the intersection of two lines, each defined by a base point and a vector.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nconst intersection$1 = (pt1, v1, pt2, v2) => {\n  // take some shortcuts for vertical and horizontal lines\n  // this also ensures we don't calculate an intersection and then discover\n  // it's actually outside the bounding box of the line\n  if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);\n  if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);\n  if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);\n  if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y);\n\n  // General case for non-overlapping segments.\n  // This algorithm is based on Schneider and Eberly.\n  // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n  const kross = crossProduct(v1, v2);\n  if (kross == 0) return null;\n  const ve = {\n    x: pt2.x - pt1.x,\n    y: pt2.y - pt1.y\n  };\n  const d1 = crossProduct(ve, v1) / kross;\n  const d2 = crossProduct(ve, v2) / kross;\n\n  // take the average of the two calculations to minimize rounding error\n  const x1 = pt1.x + d2 * v1.x,\n    x2 = pt2.x + d1 * v2.x;\n  const y1 = pt1.y + d2 * v1.y,\n    y2 = pt2.y + d1 * v2.y;\n  const x = (x1 + x2) / 2;\n  const y = (y1 + y2) / 2;\n  return {\n    x: x,\n    y: y\n  };\n};\n\nclass SweepEvent {\n  // for ordering sweep events in the sweep event queue\n  static compare(a, b) {\n    // favor event with a point that the sweep line hits first\n    const ptCmp = SweepEvent.comparePoints(a.point, b.point);\n    if (ptCmp !== 0) return ptCmp;\n\n    // the points are the same, so link them if needed\n    if (a.point !== b.point) a.link(b);\n\n    // favor right events over left\n    if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1;\n\n    // we have two matching left or right endpoints\n    // ordering of this case is the same as for their segments\n    return Segment.compare(a.segment, b.segment);\n  }\n\n  // for ordering points in sweep line order\n  static comparePoints(aPt, bPt) {\n    if (aPt.x < bPt.x) return -1;\n    if (aPt.x > bPt.x) return 1;\n    if (aPt.y < bPt.y) return -1;\n    if (aPt.y > bPt.y) return 1;\n    return 0;\n  }\n\n  // Warning: 'point' input will be modified and re-used (for performance)\n  constructor(point, isLeft) {\n    if (point.events === undefined) point.events = [this];else point.events.push(this);\n    this.point = point;\n    this.isLeft = isLeft;\n    // this.segment, this.otherSE set by factory\n  }\n  link(other) {\n    if (other.point === this.point) {\n      throw new Error(\"Tried to link already linked events\");\n    }\n    const otherEvents = other.point.events;\n    for (let i = 0, iMax = otherEvents.length; i < iMax; i++) {\n      const evt = otherEvents[i];\n      this.point.events.push(evt);\n      evt.point = this.point;\n    }\n    this.checkForConsuming();\n  }\n\n  /* Do a pass over our linked events and check to see if any pair\n   * of segments match, and should be consumed. */\n  checkForConsuming() {\n    // FIXME: The loops in this method run O(n^2) => no good.\n    //        Maintain little ordered sweep event trees?\n    //        Can we maintaining an ordering that avoids the need\n    //        for the re-sorting with getLeftmostComparator in geom-out?\n\n    // Compare each pair of events to see if other events also match\n    const numEvents = this.point.events.length;\n    for (let i = 0; i < numEvents; i++) {\n      const evt1 = this.point.events[i];\n      if (evt1.segment.consumedBy !== undefined) continue;\n      for (let j = i + 1; j < numEvents; j++) {\n        const evt2 = this.point.events[j];\n        if (evt2.consumedBy !== undefined) continue;\n        if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;\n        evt1.segment.consume(evt2.segment);\n      }\n    }\n  }\n  getAvailableLinkedEvents() {\n    // point.events is always of length 2 or greater\n    const events = [];\n    for (let i = 0, iMax = this.point.events.length; i < iMax; i++) {\n      const evt = this.point.events[i];\n      if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n        events.push(evt);\n      }\n    }\n    return events;\n  }\n\n  /**\n   * Returns a comparator function for sorting linked events that will\n   * favor the event that will give us the smallest left-side angle.\n   * All ring construction starts as low as possible heading to the right,\n   * so by always turning left as sharp as possible we'll get polygons\n   * without uncessary loops & holes.\n   *\n   * The comparator function has a compute cache such that it avoids\n   * re-computing already-computed values.\n   */\n  getLeftmostComparator(baseEvent) {\n    const cache = new Map();\n    const fillCache = linkedEvent => {\n      const nextEvent = linkedEvent.otherSE;\n      cache.set(linkedEvent, {\n        sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),\n        cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)\n      });\n    };\n    return (a, b) => {\n      if (!cache.has(a)) fillCache(a);\n      if (!cache.has(b)) fillCache(b);\n      const {\n        sine: asine,\n        cosine: acosine\n      } = cache.get(a);\n      const {\n        sine: bsine,\n        cosine: bcosine\n      } = cache.get(b);\n\n      // both on or above x-axis\n      if (asine >= 0 && bsine >= 0) {\n        if (acosine < bcosine) return 1;\n        if (acosine > bcosine) return -1;\n        return 0;\n      }\n\n      // both below x-axis\n      if (asine < 0 && bsine < 0) {\n        if (acosine < bcosine) return -1;\n        if (acosine > bcosine) return 1;\n        return 0;\n      }\n\n      // one above x-axis, one below\n      if (bsine < asine) return -1;\n      if (bsine > asine) return 1;\n      return 0;\n    };\n  }\n}\n\n// Give segments unique ID's to get consistent sorting of\n// segments and sweep events when all else is identical\nlet segmentId = 0;\nclass Segment {\n  /* This compare() function is for ordering segments in the sweep\n   * line tree, and does so according to the following criteria:\n   *\n   * Consider the vertical line that lies an infinestimal step to the\n   * right of the right-more of the two left endpoints of the input\n   * segments. Imagine slowly moving a point up from negative infinity\n   * in the increasing y direction. Which of the two segments will that\n   * point intersect first? That segment comes 'before' the other one.\n   *\n   * If neither segment would be intersected by such a line, (if one\n   * or more of the segments are vertical) then the line to be considered\n   * is directly on the right-more of the two left inputs.\n   */\n  static compare(a, b) {\n    const alx = a.leftSE.point.x;\n    const blx = b.leftSE.point.x;\n    const arx = a.rightSE.point.x;\n    const brx = b.rightSE.point.x;\n\n    // check if they're even in the same vertical plane\n    if (brx < alx) return 1;\n    if (arx < blx) return -1;\n    const aly = a.leftSE.point.y;\n    const bly = b.leftSE.point.y;\n    const ary = a.rightSE.point.y;\n    const bry = b.rightSE.point.y;\n\n    // is left endpoint of segment B the right-more?\n    if (alx < blx) {\n      // are the two segments in the same horizontal plane?\n      if (bly < aly && bly < ary) return 1;\n      if (bly > aly && bly > ary) return -1;\n\n      // is the B left endpoint colinear to segment A?\n      const aCmpBLeft = a.comparePoint(b.leftSE.point);\n      if (aCmpBLeft < 0) return 1;\n      if (aCmpBLeft > 0) return -1;\n\n      // is the A right endpoint colinear to segment B ?\n      const bCmpARight = b.comparePoint(a.rightSE.point);\n      if (bCmpARight !== 0) return bCmpARight;\n\n      // colinear segments, consider the one with left-more\n      // left endpoint to be first (arbitrary?)\n      return -1;\n    }\n\n    // is left endpoint of segment A the right-more?\n    if (alx > blx) {\n      if (aly < bly && aly < bry) return -1;\n      if (aly > bly && aly > bry) return 1;\n\n      // is the A left endpoint colinear to segment B?\n      const bCmpALeft = b.comparePoint(a.leftSE.point);\n      if (bCmpALeft !== 0) return bCmpALeft;\n\n      // is the B right endpoint colinear to segment A?\n      const aCmpBRight = a.comparePoint(b.rightSE.point);\n      if (aCmpBRight < 0) return 1;\n      if (aCmpBRight > 0) return -1;\n\n      // colinear segments, consider the one with left-more\n      // left endpoint to be first (arbitrary?)\n      return 1;\n    }\n\n    // if we get here, the two left endpoints are in the same\n    // vertical plane, ie alx === blx\n\n    // consider the lower left-endpoint to come first\n    if (aly < bly) return -1;\n    if (aly > bly) return 1;\n\n    // left endpoints are identical\n    // check for colinearity by using the left-more right endpoint\n\n    // is the A right endpoint more left-more?\n    if (arx < brx) {\n      const bCmpARight = b.comparePoint(a.rightSE.point);\n      if (bCmpARight !== 0) return bCmpARight;\n    }\n\n    // is the B right endpoint more left-more?\n    if (arx > brx) {\n      const aCmpBRight = a.comparePoint(b.rightSE.point);\n      if (aCmpBRight < 0) return 1;\n      if (aCmpBRight > 0) return -1;\n    }\n    if (arx !== brx) {\n      // are these two [almost] vertical segments with opposite orientation?\n      // if so, the one with the lower right endpoint comes first\n      const ay = ary - aly;\n      const ax = arx - alx;\n      const by = bry - bly;\n      const bx = brx - blx;\n      if (ay > ax && by < bx) return 1;\n      if (ay < ax && by > bx) return -1;\n    }\n\n    // we have colinear segments with matching orientation\n    // consider the one with more left-more right endpoint to be first\n    if (arx > brx) return 1;\n    if (arx < brx) return -1;\n\n    // if we get here, two two right endpoints are in the same\n    // vertical plane, ie arx === brx\n\n    // consider the lower right-endpoint to come first\n    if (ary < bry) return -1;\n    if (ary > bry) return 1;\n\n    // right endpoints identical as well, so the segments are idential\n    // fall back on creation order as consistent tie-breaker\n    if (a.id < b.id) return -1;\n    if (a.id > b.id) return 1;\n\n    // identical segment, ie a === b\n    return 0;\n  }\n\n  /* Warning: a reference to ringWindings input will be stored,\n   *  and possibly will be later modified */\n  constructor(leftSE, rightSE, rings, windings) {\n    this.id = ++segmentId;\n    this.leftSE = leftSE;\n    leftSE.segment = this;\n    leftSE.otherSE = rightSE;\n    this.rightSE = rightSE;\n    rightSE.segment = this;\n    rightSE.otherSE = leftSE;\n    this.rings = rings;\n    this.windings = windings;\n    // left unset for performance, set later in algorithm\n    // this.ringOut, this.consumedBy, this.prev\n  }\n  static fromRing(pt1, pt2, ring) {\n    let leftPt, rightPt, winding;\n\n    // ordering the two points according to sweep line ordering\n    const cmpPts = SweepEvent.comparePoints(pt1, pt2);\n    if (cmpPts < 0) {\n      leftPt = pt1;\n      rightPt = pt2;\n      winding = 1;\n    } else if (cmpPts > 0) {\n      leftPt = pt2;\n      rightPt = pt1;\n      winding = -1;\n    } else throw new Error(`Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`);\n    const leftSE = new SweepEvent(leftPt, true);\n    const rightSE = new SweepEvent(rightPt, false);\n    return new Segment(leftSE, rightSE, [ring], [winding]);\n  }\n\n  /* When a segment is split, the rightSE is replaced with a new sweep event */\n  replaceRightSE(newRightSE) {\n    this.rightSE = newRightSE;\n    this.rightSE.segment = this;\n    this.rightSE.otherSE = this.leftSE;\n    this.leftSE.otherSE = this.rightSE;\n  }\n  bbox() {\n    const y1 = this.leftSE.point.y;\n    const y2 = this.rightSE.point.y;\n    return {\n      ll: {\n        x: this.leftSE.point.x,\n        y: y1 < y2 ? y1 : y2\n      },\n      ur: {\n        x: this.rightSE.point.x,\n        y: y1 > y2 ? y1 : y2\n      }\n    };\n  }\n\n  /* A vector from the left point to the right */\n  vector() {\n    return {\n      x: this.rightSE.point.x - this.leftSE.point.x,\n      y: this.rightSE.point.y - this.leftSE.point.y\n    };\n  }\n  isAnEndpoint(pt) {\n    return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;\n  }\n\n  /* Compare this segment with a point.\n   *\n   * A point P is considered to be colinear to a segment if there\n   * exists a distance D such that if we travel along the segment\n   * from one * endpoint towards the other a distance D, we find\n   * ourselves at point P.\n   *\n   * Return value indicates:\n   *\n   *   1: point lies above the segment (to the left of vertical)\n   *   0: point is colinear to segment\n   *  -1: point lies below the segment (to the right of vertical)\n   */\n  comparePoint(point) {\n    if (this.isAnEndpoint(point)) return 0;\n    const lPt = this.leftSE.point;\n    const rPt = this.rightSE.point;\n    const v = this.vector();\n\n    // Exactly vertical segments.\n    if (lPt.x === rPt.x) {\n      if (point.x === lPt.x) return 0;\n      return point.x < lPt.x ? 1 : -1;\n    }\n\n    // Nearly vertical segments with an intersection.\n    // Check to see where a point on the line with matching Y coordinate is.\n    const yDist = (point.y - lPt.y) / v.y;\n    const xFromYDist = lPt.x + yDist * v.x;\n    if (point.x === xFromYDist) return 0;\n\n    // General case.\n    // Check to see where a point on the line with matching X coordinate is.\n    const xDist = (point.x - lPt.x) / v.x;\n    const yFromXDist = lPt.y + xDist * v.y;\n    if (point.y === yFromXDist) return 0;\n    return point.y < yFromXDist ? -1 : 1;\n  }\n\n  /**\n   * Given another segment, returns the first non-trivial intersection\n   * between the two segments (in terms of sweep line ordering), if it exists.\n   *\n   * A 'non-trivial' intersection is one that will cause one or both of the\n   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n   *\n   *   * endpoint of segA with endpoint of segB --> trivial\n   *   * endpoint of segA with point along segB --> non-trivial\n   *   * endpoint of segB with point along segA --> non-trivial\n   *   * point along segA with point along segB --> non-trivial\n   *\n   * If no non-trivial intersection exists, return null\n   * Else, return null.\n   */\n  getIntersection(other) {\n    // If bboxes don't overlap, there can't be any intersections\n    const tBbox = this.bbox();\n    const oBbox = other.bbox();\n    const bboxOverlap = getBboxOverlap(tBbox, oBbox);\n    if (bboxOverlap === null) return null;\n\n    // We first check to see if the endpoints can be considered intersections.\n    // This will 'snap' intersections to endpoints if possible, and will\n    // handle cases of colinearity.\n\n    const tlp = this.leftSE.point;\n    const trp = this.rightSE.point;\n    const olp = other.leftSE.point;\n    const orp = other.rightSE.point;\n\n    // does each endpoint touch the other segment?\n    // note that we restrict the 'touching' definition to only allow segments\n    // to touch endpoints that lie forward from where we are in the sweep line pass\n    const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;\n    const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;\n    const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;\n    const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;\n\n    // do left endpoints match?\n    if (touchesThisLSE && touchesOtherLSE) {\n      // these two cases are for colinear segments with matching left\n      // endpoints, and one segment being longer than the other\n      if (touchesThisRSE && !touchesOtherRSE) return trp;\n      if (!touchesThisRSE && touchesOtherRSE) return orp;\n      // either the two segments match exactly (two trival intersections)\n      // or just on their left endpoint (one trivial intersection\n      return null;\n    }\n\n    // does this left endpoint matches (other doesn't)\n    if (touchesThisLSE) {\n      // check for segments that just intersect on opposing endpoints\n      if (touchesOtherRSE) {\n        if (tlp.x === orp.x && tlp.y === orp.y) return null;\n      }\n      // t-intersection on left endpoint\n      return tlp;\n    }\n\n    // does other left endpoint matches (this doesn't)\n    if (touchesOtherLSE) {\n      // check for segments that just intersect on opposing endpoints\n      if (touchesThisRSE) {\n        if (trp.x === olp.x && trp.y === olp.y) return null;\n      }\n      // t-intersection on left endpoint\n      return olp;\n    }\n\n    // trivial intersection on right endpoints\n    if (touchesThisRSE && touchesOtherRSE) return null;\n\n    // t-intersections on just one right endpoint\n    if (touchesThisRSE) return trp;\n    if (touchesOtherRSE) return orp;\n\n    // None of our endpoints intersect. Look for a general intersection between\n    // infinite lines laid over the segments\n    const pt = intersection$1(tlp, this.vector(), olp, other.vector());\n\n    // are the segments parrallel? Note that if they were colinear with overlap,\n    // they would have an endpoint intersection and that case was already handled above\n    if (pt === null) return null;\n\n    // is the intersection found between the lines not on the segments?\n    if (!isInBbox(bboxOverlap, pt)) return null;\n\n    // round the the computed point if needed\n    return rounder.round(pt.x, pt.y);\n  }\n\n  /**\n   * Split the given segment into multiple segments on the given points.\n   *  * Each existing segment will retain its leftSE and a new rightSE will be\n   *    generated for it.\n   *  * A new segment will be generated which will adopt the original segment's\n   *    rightSE, and a new leftSE will be generated for it.\n   *  * If there are more than two points given to split on, new segments\n   *    in the middle will be generated with new leftSE and rightSE's.\n   *  * An array of the newly generated SweepEvents will be returned.\n   *\n   * Warning: input array of points is modified\n   */\n  split(point) {\n    const newEvents = [];\n    const alreadyLinked = point.events !== undefined;\n    const newLeftSE = new SweepEvent(point, true);\n    const newRightSE = new SweepEvent(point, false);\n    const oldRightSE = this.rightSE;\n    this.replaceRightSE(newRightSE);\n    newEvents.push(newRightSE);\n    newEvents.push(newLeftSE);\n    const newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());\n\n    // when splitting a nearly vertical downward-facing segment,\n    // sometimes one of the resulting new segments is vertical, in which\n    // case its left and right events may need to be swapped\n    if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n      newSeg.swapEvents();\n    }\n    if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n      this.swapEvents();\n    }\n\n    // in the point we just used to create new sweep events with was already\n    // linked to other events, we need to check if either of the affected\n    // segments should be consumed\n    if (alreadyLinked) {\n      newLeftSE.checkForConsuming();\n      newRightSE.checkForConsuming();\n    }\n    return newEvents;\n  }\n\n  /* Swap which event is left and right */\n  swapEvents() {\n    const tmpEvt = this.rightSE;\n    this.rightSE = this.leftSE;\n    this.leftSE = tmpEvt;\n    this.leftSE.isLeft = true;\n    this.rightSE.isLeft = false;\n    for (let i = 0, iMax = this.windings.length; i < iMax; i++) {\n      this.windings[i] *= -1;\n    }\n  }\n\n  /* Consume another segment. We take their rings under our wing\n   * and mark them as consumed. Use for perfectly overlapping segments */\n  consume(other) {\n    let consumer = this;\n    let consumee = other;\n    while (consumer.consumedBy) consumer = consumer.consumedBy;\n    while (consumee.consumedBy) consumee = consumee.consumedBy;\n    const cmp = Segment.compare(consumer, consumee);\n    if (cmp === 0) return; // already consumed\n    // the winner of the consumption is the earlier segment\n    // according to sweep line ordering\n    if (cmp > 0) {\n      const tmp = consumer;\n      consumer = consumee;\n      consumee = tmp;\n    }\n\n    // make sure a segment doesn't consume it's prev\n    if (consumer.prev === consumee) {\n      const tmp = consumer;\n      consumer = consumee;\n      consumee = tmp;\n    }\n    for (let i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n      const ring = consumee.rings[i];\n      const winding = consumee.windings[i];\n      const index = consumer.rings.indexOf(ring);\n      if (index === -1) {\n        consumer.rings.push(ring);\n        consumer.windings.push(winding);\n      } else consumer.windings[index] += winding;\n    }\n    consumee.rings = null;\n    consumee.windings = null;\n    consumee.consumedBy = consumer;\n\n    // mark sweep events consumed as to maintain ordering in sweep event queue\n    consumee.leftSE.consumedBy = consumer.leftSE;\n    consumee.rightSE.consumedBy = consumer.rightSE;\n  }\n\n  /* The first segment previous segment chain that is in the result */\n  prevInResult() {\n    if (this._prevInResult !== undefined) return this._prevInResult;\n    if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();\n    return this._prevInResult;\n  }\n  beforeState() {\n    if (this._beforeState !== undefined) return this._beforeState;\n    if (!this.prev) this._beforeState = {\n      rings: [],\n      windings: [],\n      multiPolys: []\n    };else {\n      const seg = this.prev.consumedBy || this.prev;\n      this._beforeState = seg.afterState();\n    }\n    return this._beforeState;\n  }\n  afterState() {\n    if (this._afterState !== undefined) return this._afterState;\n    const beforeState = this.beforeState();\n    this._afterState = {\n      rings: beforeState.rings.slice(0),\n      windings: beforeState.windings.slice(0),\n      multiPolys: []\n    };\n    const ringsAfter = this._afterState.rings;\n    const windingsAfter = this._afterState.windings;\n    const mpsAfter = this._afterState.multiPolys;\n\n    // calculate ringsAfter, windingsAfter\n    for (let i = 0, iMax = this.rings.length; i < iMax; i++) {\n      const ring = this.rings[i];\n      const winding = this.windings[i];\n      const index = ringsAfter.indexOf(ring);\n      if (index === -1) {\n        ringsAfter.push(ring);\n        windingsAfter.push(winding);\n      } else windingsAfter[index] += winding;\n    }\n\n    // calcualte polysAfter\n    const polysAfter = [];\n    const polysExclude = [];\n    for (let i = 0, iMax = ringsAfter.length; i < iMax; i++) {\n      if (windingsAfter[i] === 0) continue; // non-zero rule\n      const ring = ringsAfter[i];\n      const poly = ring.poly;\n      if (polysExclude.indexOf(poly) !== -1) continue;\n      if (ring.isExterior) polysAfter.push(poly);else {\n        if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);\n        const index = polysAfter.indexOf(ring.poly);\n        if (index !== -1) polysAfter.splice(index, 1);\n      }\n    }\n\n    // calculate multiPolysAfter\n    for (let i = 0, iMax = polysAfter.length; i < iMax; i++) {\n      const mp = polysAfter[i].multiPoly;\n      if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);\n    }\n    return this._afterState;\n  }\n\n  /* Is this segment part of the final result? */\n  isInResult() {\n    // if we've been consumed, we're not in the result\n    if (this.consumedBy) return false;\n    if (this._isInResult !== undefined) return this._isInResult;\n    const mpsBefore = this.beforeState().multiPolys;\n    const mpsAfter = this.afterState().multiPolys;\n    switch (operation.type) {\n      case \"union\":\n        {\n          // UNION - included iff:\n          //  * On one side of us there is 0 poly interiors AND\n          //  * On the other side there is 1 or more.\n          const noBefores = mpsBefore.length === 0;\n          const noAfters = mpsAfter.length === 0;\n          this._isInResult = noBefores !== noAfters;\n          break;\n        }\n      case \"intersection\":\n        {\n          // INTERSECTION - included iff:\n          //  * on one side of us all multipolys are rep. with poly interiors AND\n          //  * on the other side of us, not all multipolys are repsented\n          //    with poly interiors\n          let least;\n          let most;\n          if (mpsBefore.length < mpsAfter.length) {\n            least = mpsBefore.length;\n            most = mpsAfter.length;\n          } else {\n            least = mpsAfter.length;\n            most = mpsBefore.length;\n          }\n          this._isInResult = most === operation.numMultiPolys && least < most;\n          break;\n        }\n      case \"xor\":\n        {\n          // XOR - included iff:\n          //  * the difference between the number of multipolys represented\n          //    with poly interiors on our two sides is an odd number\n          const diff = Math.abs(mpsBefore.length - mpsAfter.length);\n          this._isInResult = diff % 2 === 1;\n          break;\n        }\n      case \"difference\":\n        {\n          // DIFFERENCE included iff:\n          //  * on exactly one side, we have just the subject\n          const isJustSubject = mps => mps.length === 1 && mps[0].isSubject;\n          this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n          break;\n        }\n      default:\n        throw new Error(`Unrecognized operation type found ${operation.type}`);\n    }\n    return this._isInResult;\n  }\n}\n\nclass RingIn {\n  constructor(geomRing, poly, isExterior) {\n    if (!Array.isArray(geomRing) || geomRing.length === 0) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    this.poly = poly;\n    this.isExterior = isExterior;\n    this.segments = [];\n    if (typeof geomRing[0][0] !== \"number\" || typeof geomRing[0][1] !== \"number\") {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    const firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);\n    this.bbox = {\n      ll: {\n        x: firstPoint.x,\n        y: firstPoint.y\n      },\n      ur: {\n        x: firstPoint.x,\n        y: firstPoint.y\n      }\n    };\n    let prevPoint = firstPoint;\n    for (let i = 1, iMax = geomRing.length; i < iMax; i++) {\n      if (typeof geomRing[i][0] !== \"number\" || typeof geomRing[i][1] !== \"number\") {\n        throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n      }\n      let point = rounder.round(geomRing[i][0], geomRing[i][1]);\n      // skip repeated points\n      if (point.x === prevPoint.x && point.y === prevPoint.y) continue;\n      this.segments.push(Segment.fromRing(prevPoint, point, this));\n      if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;\n      if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;\n      if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;\n      if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;\n      prevPoint = point;\n    }\n    // add segment from last to first if last is not the same as first\n    if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {\n      this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));\n    }\n  }\n  getSweepEvents() {\n    const sweepEvents = [];\n    for (let i = 0, iMax = this.segments.length; i < iMax; i++) {\n      const segment = this.segments[i];\n      sweepEvents.push(segment.leftSE);\n      sweepEvents.push(segment.rightSE);\n    }\n    return sweepEvents;\n  }\n}\nclass PolyIn {\n  constructor(geomPoly, multiPoly) {\n    if (!Array.isArray(geomPoly)) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    this.exteriorRing = new RingIn(geomPoly[0], this, true);\n    // copy by value\n    this.bbox = {\n      ll: {\n        x: this.exteriorRing.bbox.ll.x,\n        y: this.exteriorRing.bbox.ll.y\n      },\n      ur: {\n        x: this.exteriorRing.bbox.ur.x,\n        y: this.exteriorRing.bbox.ur.y\n      }\n    };\n    this.interiorRings = [];\n    for (let i = 1, iMax = geomPoly.length; i < iMax; i++) {\n      const ring = new RingIn(geomPoly[i], this, false);\n      if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;\n      if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;\n      if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;\n      if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;\n      this.interiorRings.push(ring);\n    }\n    this.multiPoly = multiPoly;\n  }\n  getSweepEvents() {\n    const sweepEvents = this.exteriorRing.getSweepEvents();\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringSweepEvents = this.interiorRings[i].getSweepEvents();\n      for (let j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(ringSweepEvents[j]);\n      }\n    }\n    return sweepEvents;\n  }\n}\nclass MultiPolyIn {\n  constructor(geom, isSubject) {\n    if (!Array.isArray(geom)) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    try {\n      // if the input looks like a polygon, convert it to a multipolygon\n      if (typeof geom[0][0][0] === \"number\") geom = [geom];\n    } catch (ex) {\n      // The input is either malformed or has empty arrays.\n      // In either case, it will be handled later on.\n    }\n    this.polys = [];\n    this.bbox = {\n      ll: {\n        x: Number.POSITIVE_INFINITY,\n        y: Number.POSITIVE_INFINITY\n      },\n      ur: {\n        x: Number.NEGATIVE_INFINITY,\n        y: Number.NEGATIVE_INFINITY\n      }\n    };\n    for (let i = 0, iMax = geom.length; i < iMax; i++) {\n      const poly = new PolyIn(geom[i], this);\n      if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;\n      if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;\n      if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;\n      if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;\n      this.polys.push(poly);\n    }\n    this.isSubject = isSubject;\n  }\n  getSweepEvents() {\n    const sweepEvents = [];\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polySweepEvents = this.polys[i].getSweepEvents();\n      for (let j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(polySweepEvents[j]);\n      }\n    }\n    return sweepEvents;\n  }\n}\n\nclass RingOut {\n  /* Given the segments from the sweep line pass, compute & return a series\n   * of closed rings from all the segments marked to be part of the result */\n  static factory(allSegments) {\n    const ringsOut = [];\n    for (let i = 0, iMax = allSegments.length; i < iMax; i++) {\n      const segment = allSegments[i];\n      if (!segment.isInResult() || segment.ringOut) continue;\n      let prevEvent = null;\n      let event = segment.leftSE;\n      let nextEvent = segment.rightSE;\n      const events = [event];\n      const startingPoint = event.point;\n      const intersectionLEs = [];\n\n      /* Walk the chain of linked events to form a closed ring */\n      while (true) {\n        prevEvent = event;\n        event = nextEvent;\n        events.push(event);\n\n        /* Is the ring complete? */\n        if (event.point === startingPoint) break;\n        while (true) {\n          const availableLEs = event.getAvailableLinkedEvents();\n\n          /* Did we hit a dead end? This shouldn't happen.\n           * Indicates some earlier part of the algorithm malfunctioned. */\n          if (availableLEs.length === 0) {\n            const firstPt = events[0].point;\n            const lastPt = events[events.length - 1].point;\n            throw new Error(`Unable to complete output ring starting at [${firstPt.x},` + ` ${firstPt.y}]. Last matching segment found ends at` + ` [${lastPt.x}, ${lastPt.y}].`);\n          }\n\n          /* Only one way to go, so cotinue on the path */\n          if (availableLEs.length === 1) {\n            nextEvent = availableLEs[0].otherSE;\n            break;\n          }\n\n          /* We must have an intersection. Check for a completed loop */\n          let indexLE = null;\n          for (let j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n            if (intersectionLEs[j].point === event.point) {\n              indexLE = j;\n              break;\n            }\n          }\n          /* Found a completed loop. Cut that off and make a ring */\n          if (indexLE !== null) {\n            const intersectionLE = intersectionLEs.splice(indexLE)[0];\n            const ringEvents = events.splice(intersectionLE.index);\n            ringEvents.unshift(ringEvents[0].otherSE);\n            ringsOut.push(new RingOut(ringEvents.reverse()));\n            continue;\n          }\n          /* register the intersection */\n          intersectionLEs.push({\n            index: events.length,\n            point: event.point\n          });\n          /* Choose the left-most option to continue the walk */\n          const comparator = event.getLeftmostComparator(prevEvent);\n          nextEvent = availableLEs.sort(comparator)[0].otherSE;\n          break;\n        }\n      }\n      ringsOut.push(new RingOut(events));\n    }\n    return ringsOut;\n  }\n  constructor(events) {\n    this.events = events;\n    for (let i = 0, iMax = events.length; i < iMax; i++) {\n      events[i].segment.ringOut = this;\n    }\n    this.poly = null;\n  }\n  getGeom() {\n    // Remove superfluous points (ie extra points along a straight line),\n    let prevPt = this.events[0].point;\n    const points = [prevPt];\n    for (let i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n      const pt = this.events[i].point;\n      const nextPt = this.events[i + 1].point;\n      if (compareVectorAngles(pt, prevPt, nextPt) === 0) continue;\n      points.push(pt);\n      prevPt = pt;\n    }\n\n    // ring was all (within rounding error of angle calc) colinear points\n    if (points.length === 1) return null;\n\n    // check if the starting point is necessary\n    const pt = points[0];\n    const nextPt = points[1];\n    if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();\n    points.push(points[0]);\n    const step = this.isExteriorRing() ? 1 : -1;\n    const iStart = this.isExteriorRing() ? 0 : points.length - 1;\n    const iEnd = this.isExteriorRing() ? points.length : -1;\n    const orderedPoints = [];\n    for (let i = iStart; i != iEnd; i += step) orderedPoints.push([points[i].x, points[i].y]);\n    return orderedPoints;\n  }\n  isExteriorRing() {\n    if (this._isExteriorRing === undefined) {\n      const enclosing = this.enclosingRing();\n      this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n    }\n    return this._isExteriorRing;\n  }\n  enclosingRing() {\n    if (this._enclosingRing === undefined) {\n      this._enclosingRing = this._calcEnclosingRing();\n    }\n    return this._enclosingRing;\n  }\n\n  /* Returns the ring that encloses this one, if any */\n  _calcEnclosingRing() {\n    // start with the ealier sweep line event so that the prevSeg\n    // chain doesn't lead us inside of a loop of ours\n    let leftMostEvt = this.events[0];\n    for (let i = 1, iMax = this.events.length; i < iMax; i++) {\n      const evt = this.events[i];\n      if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n    }\n    let prevSeg = leftMostEvt.segment.prevInResult();\n    let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n    while (true) {\n      // no segment found, thus no ring can enclose us\n      if (!prevSeg) return null;\n\n      // no segments below prev segment found, thus the ring of the prev\n      // segment must loop back around and enclose us\n      if (!prevPrevSeg) return prevSeg.ringOut;\n\n      // if the two segments are of different rings, the ring of the prev\n      // segment must either loop around us or the ring of the prev prev\n      // seg, which would make us and the ring of the prev peers\n      if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n        if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n          return prevSeg.ringOut;\n        } else return prevSeg.ringOut.enclosingRing();\n      }\n\n      // two segments are from the same ring, so this was a penisula\n      // of that ring. iterate downward, keep searching\n      prevSeg = prevPrevSeg.prevInResult();\n      prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n    }\n  }\n}\nclass PolyOut {\n  constructor(exteriorRing) {\n    this.exteriorRing = exteriorRing;\n    exteriorRing.poly = this;\n    this.interiorRings = [];\n  }\n  addInterior(ring) {\n    this.interiorRings.push(ring);\n    ring.poly = this;\n  }\n  getGeom() {\n    const geom = [this.exteriorRing.getGeom()];\n    // exterior ring was all (within rounding error of angle calc) colinear points\n    if (geom[0] === null) return null;\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringGeom = this.interiorRings[i].getGeom();\n      // interior ring was all (within rounding error of angle calc) colinear points\n      if (ringGeom === null) continue;\n      geom.push(ringGeom);\n    }\n    return geom;\n  }\n}\nclass MultiPolyOut {\n  constructor(rings) {\n    this.rings = rings;\n    this.polys = this._composePolys(rings);\n  }\n  getGeom() {\n    const geom = [];\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polyGeom = this.polys[i].getGeom();\n      // exterior ring was all (within rounding error of angle calc) colinear points\n      if (polyGeom === null) continue;\n      geom.push(polyGeom);\n    }\n    return geom;\n  }\n  _composePolys(rings) {\n    const polys = [];\n    for (let i = 0, iMax = rings.length; i < iMax; i++) {\n      const ring = rings[i];\n      if (ring.poly) continue;\n      if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {\n        const enclosingRing = ring.enclosingRing();\n        if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));\n        enclosingRing.poly.addInterior(ring);\n      }\n    }\n    return polys;\n  }\n}\n\n/**\n * NOTE:  We must be careful not to change any segments while\n *        they are in the SplayTree. AFAIK, there's no way to tell\n *        the tree to rebalance itself - thus before splitting\n *        a segment that's in the tree, we remove it from the tree,\n *        do the split, then re-insert it. (Even though splitting a\n *        segment *shouldn't* change its correct position in the\n *        sweep line tree, the reality is because of rounding errors,\n *        it sometimes does.)\n */\n\nclass SweepLine {\n  constructor(queue) {\n    let comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;\n    this.queue = queue;\n    this.tree = new SplayTree(comparator);\n    this.segments = [];\n  }\n  process(event) {\n    const segment = event.segment;\n    const newEvents = [];\n\n    // if we've already been consumed by another segment,\n    // clean up our body parts and get out\n    if (event.consumedBy) {\n      if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);\n      return newEvents;\n    }\n    const node = event.isLeft ? this.tree.add(segment) : this.tree.find(segment);\n    if (!node) throw new Error(`Unable to find segment #${segment.id} ` + `[${segment.leftSE.point.x}, ${segment.leftSE.point.y}] -> ` + `[${segment.rightSE.point.x}, ${segment.rightSE.point.y}] ` + \"in SweepLine tree.\");\n    let prevNode = node;\n    let nextNode = node;\n    let prevSeg = undefined;\n    let nextSeg = undefined;\n\n    // skip consumed segments still in tree\n    while (prevSeg === undefined) {\n      prevNode = this.tree.prev(prevNode);\n      if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;\n    }\n\n    // skip consumed segments still in tree\n    while (nextSeg === undefined) {\n      nextNode = this.tree.next(nextNode);\n      if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;\n    }\n    if (event.isLeft) {\n      // Check for intersections against the previous segment in the sweep line\n      let prevMySplitter = null;\n      if (prevSeg) {\n        const prevInter = prevSeg.getIntersection(segment);\n        if (prevInter !== null) {\n          if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;\n          if (!prevSeg.isAnEndpoint(prevInter)) {\n            const newEventsFromSplit = this._splitSafely(prevSeg, prevInter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n        }\n      }\n\n      // Check for intersections against the next segment in the sweep line\n      let nextMySplitter = null;\n      if (nextSeg) {\n        const nextInter = nextSeg.getIntersection(segment);\n        if (nextInter !== null) {\n          if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;\n          if (!nextSeg.isAnEndpoint(nextInter)) {\n            const newEventsFromSplit = this._splitSafely(nextSeg, nextInter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n        }\n      }\n\n      // For simplicity, even if we find more than one intersection we only\n      // spilt on the 'earliest' (sweep-line style) of the intersections.\n      // The other intersection will be handled in a future process().\n      if (prevMySplitter !== null || nextMySplitter !== null) {\n        let mySplitter = null;\n        if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {\n          const cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);\n          mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;\n        }\n\n        // Rounding errors can cause changes in ordering,\n        // so remove afected segments and right sweep events before splitting\n        this.queue.remove(segment.rightSE);\n        newEvents.push(segment.rightSE);\n        const newEventsFromSplit = segment.split(mySplitter);\n        for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n          newEvents.push(newEventsFromSplit[i]);\n        }\n      }\n      if (newEvents.length > 0) {\n        // We found some intersections, so re-do the current event to\n        // make sure sweep line ordering is totally consistent for later\n        // use with the segment 'prev' pointers\n        this.tree.remove(segment);\n        newEvents.push(event);\n      } else {\n        // done with left event\n        this.segments.push(segment);\n        segment.prev = prevSeg;\n      }\n    } else {\n      // event.isRight\n\n      // since we're about to be removed from the sweep line, check for\n      // intersections between our previous and next segments\n      if (prevSeg && nextSeg) {\n        const inter = prevSeg.getIntersection(nextSeg);\n        if (inter !== null) {\n          if (!prevSeg.isAnEndpoint(inter)) {\n            const newEventsFromSplit = this._splitSafely(prevSeg, inter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n          if (!nextSeg.isAnEndpoint(inter)) {\n            const newEventsFromSplit = this._splitSafely(nextSeg, inter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n        }\n      }\n      this.tree.remove(segment);\n    }\n    return newEvents;\n  }\n\n  /* Safely split a segment that is currently in the datastructures\n   * IE - a segment other than the one that is currently being processed. */\n  _splitSafely(seg, pt) {\n    // Rounding errors can cause changes in ordering,\n    // so remove afected segments and right sweep events before splitting\n    // removeNode() doesn't work, so have re-find the seg\n    // https://github.com/w8r/splay-tree/pull/5\n    this.tree.remove(seg);\n    const rightSE = seg.rightSE;\n    this.queue.remove(rightSE);\n    const newEvents = seg.split(pt);\n    newEvents.push(rightSE);\n    // splitting can trigger consumption\n    if (seg.consumedBy === undefined) this.tree.add(seg);\n    return newEvents;\n  }\n}\n\n// Limits on iterative processes to prevent infinite loops - usually caused by floating-point math round-off errors.\nconst POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== \"undefined\" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;\nconst POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== \"undefined\" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;\nclass Operation {\n  run(type, geom, moreGeoms) {\n    operation.type = type;\n    rounder.reset();\n\n    /* Convert inputs to MultiPoly objects */\n    const multipolys = [new MultiPolyIn(geom, true)];\n    for (let i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n      multipolys.push(new MultiPolyIn(moreGeoms[i], false));\n    }\n    operation.numMultiPolys = multipolys.length;\n\n    /* BBox optimization for difference operation\n     * If the bbox of a multipolygon that's part of the clipping doesn't\n     * intersect the bbox of the subject at all, we can just drop that\n     * multiploygon. */\n    if (operation.type === \"difference\") {\n      // in place removal\n      const subject = multipolys[0];\n      let i = 1;\n      while (i < multipolys.length) {\n        if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null) i++;else multipolys.splice(i, 1);\n      }\n    }\n\n    /* BBox optimization for intersection operation\n     * If we can find any pair of multipolygons whose bbox does not overlap,\n     * then the result will be empty. */\n    if (operation.type === \"intersection\") {\n      // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,\n      //       it could be optimized to O(n * ln(n))\n      for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n        const mpA = multipolys[i];\n        for (let j = i + 1, jMax = multipolys.length; j < jMax; j++) {\n          if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];\n        }\n      }\n    }\n\n    /* Put segment endpoints in a priority queue */\n    const queue = new SplayTree(SweepEvent.compare);\n    for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n      const sweepEvents = multipolys[i].getSweepEvents();\n      for (let j = 0, jMax = sweepEvents.length; j < jMax; j++) {\n        queue.insert(sweepEvents[j]);\n        if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          throw new Error(\"Infinite loop when putting segment endpoints in a priority queue \" + \"(queue size too big).\");\n        }\n      }\n    }\n\n    /* Pass the sweep line over those endpoints */\n    const sweepLine = new SweepLine(queue);\n    let prevQueueSize = queue.size;\n    let node = queue.pop();\n    while (node) {\n      const evt = node.key;\n      if (queue.size === prevQueueSize) {\n        // prevents an infinite loop, an otherwise common manifestation of bugs\n        const seg = evt.segment;\n        throw new Error(`Unable to pop() ${evt.isLeft ? \"left\" : \"right\"} SweepEvent ` + `[${evt.point.x}, ${evt.point.y}] from segment #${seg.id} ` + `[${seg.leftSE.point.x}, ${seg.leftSE.point.y}] -> ` + `[${seg.rightSE.point.x}, ${seg.rightSE.point.y}] from queue.`);\n      }\n      if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n        // prevents an infinite loop, an otherwise common manifestation of bugs\n        throw new Error(\"Infinite loop when passing sweep line over endpoints \" + \"(queue size too big).\");\n      }\n      if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {\n        // prevents an infinite loop, an otherwise common manifestation of bugs\n        throw new Error(\"Infinite loop when passing sweep line over endpoints \" + \"(too many sweep line segments).\");\n      }\n      const newEvents = sweepLine.process(evt);\n      for (let i = 0, iMax = newEvents.length; i < iMax; i++) {\n        const evt = newEvents[i];\n        if (evt.consumedBy === undefined) queue.insert(evt);\n      }\n      prevQueueSize = queue.size;\n      node = queue.pop();\n    }\n\n    // free some memory we don't need anymore\n    rounder.reset();\n\n    /* Collect and compile segments we're keeping into a multipolygon */\n    const ringsOut = RingOut.factory(sweepLine.segments);\n    const result = new MultiPolyOut(ringsOut);\n    return result.getGeom();\n  }\n}\n\n// singleton available by import\nconst operation = new Operation();\n\nconst union = function (geom) {\n  for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    moreGeoms[_key - 1] = arguments[_key];\n  }\n  return operation.run(\"union\", geom, moreGeoms);\n};\nconst intersection = function (geom) {\n  for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    moreGeoms[_key2 - 1] = arguments[_key2];\n  }\n  return operation.run(\"intersection\", geom, moreGeoms);\n};\nconst xor = function (geom) {\n  for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    moreGeoms[_key3 - 1] = arguments[_key3];\n  }\n  return operation.run(\"xor\", geom, moreGeoms);\n};\nconst difference = function (subjectGeom) {\n  for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    clippingGeoms[_key4 - 1] = arguments[_key4];\n  }\n  return operation.run(\"difference\", subjectGeom, clippingGeoms);\n};\nvar index = {\n  union: union,\n  intersection: intersection,\n  xor: xor,\n  difference: difference\n};\n\nexport { index as default };\n","import { multiPolygon, polygon, } from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\nimport polygonClipping from \"polygon-clipping\";\n/**\n * Takes two {@link Polygon|polygon} or {@link MultiPolygon|multi-polygon} geometries and\n * finds their polygonal intersection. If they don't intersect, returns null.\n *\n * @name intersect\n * @param {Feature<Polygon | MultiPolygon>} poly1 the first polygon or multipolygon\n * @param {Feature<Polygon | MultiPolygon>} poly2 the second polygon or multipolygon\n * @param {Object} [options={}] Optional Parameters\n * @param {Object} [options.properties={}] Translate GeoJSON Properties to Feature\n * @returns {Feature|null} returns a feature representing the area they share (either a {@link Polygon} or\n * {@link MultiPolygon}). If they do not share any area, returns `null`.\n * @example\n * var poly1 = turf.polygon([[\n *   [-122.801742, 45.48565],\n *   [-122.801742, 45.60491],\n *   [-122.584762, 45.60491],\n *   [-122.584762, 45.48565],\n *   [-122.801742, 45.48565]\n * ]]);\n *\n * var poly2 = turf.polygon([[\n *   [-122.520217, 45.535693],\n *   [-122.64038, 45.553967],\n *   [-122.720031, 45.526554],\n *   [-122.669906, 45.507309],\n *   [-122.723464, 45.446643],\n *   [-122.532577, 45.408574],\n *   [-122.487258, 45.477466],\n *   [-122.520217, 45.535693]\n * ]]);\n *\n * var intersection = turf.intersect(poly1, poly2);\n *\n * //addToMap\n * var addToMap = [poly1, poly2, intersection];\n */\nexport default function intersect(poly1, poly2, options) {\n    if (options === void 0) { options = {}; }\n    var geom1 = getGeom(poly1);\n    var geom2 = getGeom(poly2);\n    var intersection = polygonClipping.intersection(geom1.coordinates, geom2.coordinates);\n    if (intersection.length === 0)\n        return null;\n    if (intersection.length === 1)\n        return polygon(intersection[0], options.properties);\n    return multiPolygon(intersection, options.properties);\n}\n","/*\n * @description:\n */\nimport { kriging } from \"./kriging\";\n\nimport intersect from \"@turf/intersect\";\n\nfunction _getKrigingGridInfo(featureCollection, weight, krigingParams) {\n  //先获取featureCollection的bbox\n  let values = [],\n    lons = [],\n    lats = [];\n  let extent = [100000000, 100000000, -100000000, -100000000];\n  featureCollection.features.forEach((feature) => {\n    //提取插值权重字段，准备克里金插值使用\n    values.push(feature.properties[weight]);\n    lons.push(feature.geometry.coordinates[0]);\n    lats.push(feature.geometry.coordinates[1]);\n    if (extent[0] > feature.geometry.coordinates[0])\n      extent[0] = feature.geometry.coordinates[0];\n    if (extent[1] > feature.geometry.coordinates[1])\n      extent[1] = feature.geometry.coordinates[1];\n    if (extent[2] < feature.geometry.coordinates[0])\n      extent[2] = feature.geometry.coordinates[0];\n    if (extent[3] < feature.geometry.coordinates[1])\n      extent[3] = feature.geometry.coordinates[1];\n  });\n  let variogram = kriging.train(\n    values,\n    lons,\n    lats,\n    krigingParams.model,\n    krigingParams.sigma2,\n    krigingParams.alpha\n  );\n  let gridinfo = kriging.getGridInfo(extent, variogram, 200);\n  return gridinfo;\n}\n\n/*\n* 克里金生成矢量等值面，浏览器和node都可以使用\n* @param {json} featureCollection：必填，已有点数据，geojson格式\n* @param {string} weight：必填，插值所依赖的圈中字段\n* @param {object) krigingParams：必填，克里金插值算法参数设置\n    krigingParams:{\n         krigingModel:'exponential','gaussian','spherical'，三选一\n         krigingSigma2:\n         krigingAlpha:\n    }\n* @param {array} breaks：必填，等值面分级区间\n*/\nfunction getVectorContour(featureCollection, weight, krigingParams, breaks) {\n  let gridinfo = _getKrigingGridInfo(featureCollection, weight, krigingParams);\n  let vectorContour = kriging.getVectorContour(gridinfo, breaks);\n  return vectorContour;\n}\n\n/*\n* 克里金生成矢量等值面，浏览器和node都可以使用\n* @param {json} featureCollection：必填，已有点数据，geojson格式\n* @param {string} weight：必填，插值所依赖的圈中字段\n* @param {object) krigingParams：必填，克里金插值算法参数设置\n    krigingParams:{\n         krigingModel:'exponential','gaussian','spherical'，三选一\n         krigingSigma2:\n         krigingAlpha:\n    }\n* @param {array} breaks：必填，等值面分级区间\n* @param {array} boundaryCoordinates 必填，边界经纬度\n*/\nfunction getVectorContourWithClip(\n  featureCollection,\n  weight,\n  krigingParams,\n  breaks,\n  boundaryCoordinates\n) {\n  let gridinfo = _getKrigingGridInfo(featureCollection, weight, krigingParams);\n  let vectorContour = kriging.getVectorContour(gridinfo, breaks);\n  let clip = {\n    type: \"Feature\",\n    properties: {},\n    geometry: {\n      type: \"Polygon\",\n      coordinates: boundaryCoordinates,\n    },\n  };\n  let clip_features = vectorContour.features.map((feature) => {\n    let turfClip = intersect(feature, clip);\n    if (turfClip !== null) {\n      turfClip.properties = feature.properties;\n    }\n    return turfClip;\n  });\n  clip_features = clip_features.filter((item) => item !== null);\n  return clip_features;\n}\n\n/*\n* 克里金生成栅格等值面并绘制到canvas上，仅浏览器中使用\n* @param {json} featureCollection：必填，已有点数据，geojson格式\n* @param {string} weight：必填，插值所依赖的圈中字段\n* @param {object) krigingParams：必填，克里金插值算法参数设置\n    krigingParams:{\n         krigingModel:'exponential','gaussian','spherical'，三选一\n         krigingSigma2:\n         krigingAlpha:\n    }\n* @param {dom) canvas：必填，绑定渲染的canvas dom\n* @param {array) colors：必填，等值面分级区间\n*/\nfunction drawCanvasContour(\n  featureCollection,\n  weight,\n  krigingParams,\n  canvas,\n  xlim,\n  ylim,\n  colors\n) {\n  let gridinfo = _getKrigingGridInfo(featureCollection, weight, krigingParams);\n  kriging.drawCanvasContour(gridinfo, canvas, xlim, ylim, colors);\n}\n\nexport { getVectorContour, getVectorContourWithClip, drawCanvasContour };\n"],"names":["ascending$1","a","b","NaN","compare","f","ascending","length","d","x","e10","Math","sqrt","e5","e2","thresholdSturges","values","ceil","log","LN2","slice","Array","prototype","constant","contains","ring","hole","c","i","n","ringContains","point","y","j","pi","xi","yi","pj","xj","yj","segmentContains","p","q","r","collinear","noop","cases","d3_contours","dx","dy","threshold","smooth","smoothLinear","contours","tz","isArray","sort","domain","valueof","value","min","max","extent","start","stop","count","step0","abs","step1","pow","floor","LN10","error","tickStep","step","arguments","range","map","contour","polygons","holes","callback","t0","t1","t2","t3","fragmentByStart","fragmentByEnd","forEach","stitch","line","g","end","startIndex","index","endIndex","push","concat","unshift","isorings","area","polygon","type","coordinates","v0","xt","yt","v1","size","_","_0","_1","Error","thresholds","call","kriging_matrix_diag","Z","rep","kriging_matrix_add","X","Y","m","kriging_matrix_multiply","k","kriging_matrix_chol","kriging_matrix_chol2inv","sum","kriging_matrix_solve","icol","irow","l","ll","big","dum","pivinv","temp","indxc","indxr","ipiv","kriging_variogram_gaussian","h","nugget","sill","A","exp","kriging_variogram_exponential","kriging_variogram_spherical","apply","this","mean","arrayn","v","pip","kriging","polygon_pixel2geos","gridInfo","coor","xlim","x_resolution","y_resolution","ylim","feature","geom","properties","options","feat","id","bbox","geometry","getGeom","geojson","train","t","model","sigma2","alpha","variogram","distance","lags","tolerance","lag","semi","Xt","kriging_matrix_transpose","cloneZ","W","K","C","cloneC","M","predict","variance","getGridInfo","width","x_width","y_width","xtarget","ytarget","grid","zlim","geoX_width","geoY_width","getVectorContour","breaks","_contours","dataset","features","_loop","drawCanvasContour","canvas","colors","ctx","getContext","clearRect","height","wx","wy","_index","undefined","z","fillStyle","fillRect","round","splitter","resulterrbound","elen","e","flen","Q","Qnew","hh","bvirt","enow","fnow","eindex","findex","hindex","vec","Float64Array","ccwerrboundB","ccwerrboundC","B","C1","C2","D","u","orient2d","ax","ay","bx","by","cx","cy","detleft","detright","det","detsum","acxtail","acytail","bcxtail","bcytail","ahi","alo","bhi","blo","_i","_j","s1","s0","u3","acx","bcx","acy","bcy","estimate","errbound","C1len","C2len","Dlen","orient2dadapt","isInBbox","ur","getBboxOverlap","b1","b2","lowerX","upperX","epsilon","Number","EPSILON","EPSILON_SQ","cmp","ab","CoordRounder","constructor","tree","SplayTree","coord","node","add","prevNode","prev","key","remove","nextNode","next","rounder","reset","xRounder","yRounder","crossProduct","dotProduct","compareVectorAngles","basePt","endPt1","endPt2","res","sineOfAngle","pShared","pBase","pAngle","vBase","vAngle","cosineOfAngle","horizontalIntersection","pt","verticalIntersection","SweepEvent","ptCmp","comparePoints","link","isLeft","Segment","segment","aPt","bPt","events","other","otherEvents","iMax","evt","checkForConsuming","numEvents","evt1","consumedBy","evt2","otherSE","consume","getAvailableLinkedEvents","ringOut","isInResult","getLeftmostComparator","baseEvent","cache","Map","fillCache","linkedEvent","nextEvent","set","sine","cosine","has","asine","acosine","get","bsine","bcosine","segmentId","alx","leftSE","blx","arx","rightSE","brx","aly","bly","ary","bry","aCmpBLeft","comparePoint","bCmpARight","bCmpALeft","aCmpBRight","rings","windings","fromRing","pt1","pt2","leftPt","rightPt","winding","cmpPts","replaceRightSE","newRightSE","y1","y2","vector","isAnEndpoint","lPt","rPt","yDist","xFromYDist","xDist","yFromXDist","getIntersection","tBbox","oBbox","bboxOverlap","tlp","trp","olp","orp","touchesOtherLSE","touchesThisLSE","touchesOtherRSE","touchesThisRSE","v2","kross","ve","d1","d2","intersection$1","split","newEvents","alreadyLinked","newLeftSE","oldRightSE","newSeg","swapEvents","tmpEvt","consumer","consumee","tmp","indexOf","prevInResult","_prevInResult","beforeState","_beforeState","seg","afterState","multiPolys","_afterState","ringsAfter","windingsAfter","mpsAfter","polysAfter","polysExclude","poly","isExterior","splice","mp","multiPoly","_isInResult","mpsBefore","operation","noBefores","noAfters","least","most","numMultiPolys","diff","isJustSubject","mps","isSubject","RingIn","geomRing","segments","firstPoint","prevPoint","getSweepEvents","sweepEvents","PolyIn","geomPoly","exteriorRing","interiorRings","ringSweepEvents","jMax","MultiPolyIn","ex","polys","POSITIVE_INFINITY","NEGATIVE_INFINITY","polySweepEvents","RingOut","factory","allSegments","ringsOut","prevEvent","event","startingPoint","intersectionLEs","availableLEs","firstPt","lastPt","indexLE","intersectionLE","ringEvents","reverse","comparator","prevPt","points","nextPt","shift","isExteriorRing","iStart","iEnd","orderedPoints","_isExteriorRing","enclosing","enclosingRing","_enclosingRing","_calcEnclosingRing","leftMostEvt","prevSeg","prevPrevSeg","PolyOut","addInterior","ringGeom","MultiPolyOut","_composePolys","polyGeom","SweepLine","queue","process","find","nextSeg","prevMySplitter","prevInter","newEventsFromSplit","_splitSafely","nextMySplitter","nextInter","mySplitter","inter","POLYGON_CLIPPING_MAX_QUEUE_SIZE","env","POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS","run","moreGeoms","multipolys","subject","mpA","insert","sweepLine","prevQueueSize","pop","union","_len","_key","intersection","_len2","_key2","xor","_len3","_key3","difference","subjectGeom","_len4","clippingGeoms","_key4","intersect","poly1","poly2","geom1","geom2","polygonClipping","coordinates_1","multiPolygon","_getKrigingGridInfo","featureCollection","weight","krigingParams","lons","lats","gridinfo","boundaryCoordinates","vectorContour","clip","clip_features","turfClip","filter","item"],"mappings":"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"}